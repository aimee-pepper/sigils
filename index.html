<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sigil Generator - Heat Map Edition</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <style>
    :root {
      /* Base unit - everything scales from this */
      --base: min(440px, 85vw);

      /* Layout containers */
      --header-width: var(--base);
      --detail-min: calc(var(--base) * 0.909);
      --error-log-w: calc(var(--base) * 0.795);
      --error-list-h: calc(var(--base) * 0.682);
      --sidebar-w: calc(var(--base) * 0.636);

      /* Sigil sizes */
      --chained-gen: calc(var(--base) * 1.364);
      --chained-display: calc(var(--base) * 0.682);
      --gen-size: calc(var(--base) * 0.455);
      --card-display: calc(var(--base) * 0.382);
      --fav-display: calc(var(--base) * 0.341);

      /* Font sizes */
      --font-h1: calc(var(--base) * 0.041);
      --font-section: calc(var(--base) * 0.032);
      --font-primary: calc(var(--base) * 0.030);
      --font-secondary: calc(var(--base) * 0.027);
      --font-tertiary: calc(var(--base) * 0.025);
      --font-small: calc(var(--base) * 0.023);
      --font-tiny: calc(var(--base) * 0.020);
      --font-icon: calc(var(--base) * 0.018);

      /* Spacing */
      --sp-xl: calc(var(--base) * 0.091);   /* 40px */
      --sp-lg: calc(var(--base) * 0.073);   /* 32px */
      --sp-md: calc(var(--base) * 0.045);   /* 20px */
      --sp-sm: calc(var(--base) * 0.036);   /* 16px */
      --sp-xs: calc(var(--base) * 0.027);   /* 12px */
      --sp-2xs: calc(var(--base) * 0.023);  /* 10px */
      --sp-3xs: calc(var(--base) * 0.018);  /* 8px */
      --sp-4xs: calc(var(--base) * 0.014);  /* 6px */
      --sp-5xs: calc(var(--base) * 0.009);  /* 4px */
      --sp-6xs: calc(var(--base) * 0.005);  /* 2px */
      --sp-px: calc(var(--base) * 0.002);   /* 1px */

      /* Border radius */
      --radius-lg: calc(var(--base) * 0.023);  /* 10px */
      --radius-md: calc(var(--base) * 0.018);  /* 8px */
      --radius-sm: calc(var(--base) * 0.014);  /* 6px */
      --radius-xs: calc(var(--base) * 0.009);  /* 4px */
      --radius-2xs: calc(var(--base) * 0.007); /* 3px */

      /* Element dimensions */
      --badge-size: calc(var(--base) * 0.041);  /* 18px */
      --scrollbar-w: calc(var(--base) * 0.027); /* 12px */
      --scrollbar-track: calc(var(--base) * 0.018); /* 8px */

      /* Tabs bar height (for calc) */
      --tabs-height: calc(var(--base) * 0.114); /* ~50px */
    }

    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f4;
      min-height: 100vh;
    }
    .app-container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    .tabs-bar {
      background: white;
      border-bottom: var(--sp-px) solid #e4e4e7;
      padding: 0 var(--sp-md);
      display: flex;
      gap: 0;
      overflow-x: auto;
      align-items: center;
    }
    .tabs-bar-left {
      display: flex;
      align-items: center;
      flex: 1;
    }
    .tabs-bar-right {
      display: flex;
      align-items: center;
      gap: var(--sp-3xs);
      margin-left: auto;
    }
    .topbar-toggle {
      padding: var(--sp-4xs) var(--sp-2xs);
      border: var(--sp-px) solid #e4e4e7;
      border-radius: var(--radius-sm);
      background: white;
      font-size: var(--font-tertiary);
      color: #71717a;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: var(--sp-4xs);
      transition: all 0.15s;
    }
    .topbar-toggle:hover {
      border-color: #a1a1aa;
      background: #fafaf9;
    }
    .topbar-toggle.has-errors {
      background: #fef2f2;
      border-color: #fecaca;
      color: #dc2626;
    }
    .tab {
      padding: var(--sp-xs) var(--sp-sm);
      border: none;
      background: none;
      font-size: var(--font-primary);
      color: #71717a;
      cursor: pointer;
      border-bottom: var(--sp-6xs) solid transparent;
      white-space: nowrap;
      transition: all 0.15s;
    }
    .tab:hover {
      color: #3f3f46;
      background: #fafaf9;
    }
    .tab.active {
      color: #3f3f46;
      border-bottom-color: #3f3f46;
      font-weight: 500;
    }
    .examples-toggle {
      padding: var(--sp-xs) var(--sp-sm);
      border: none;
      background: none;
      font-size: var(--font-primary);
      color: #a1a1aa;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: var(--sp-4xs);
      white-space: nowrap;
      transition: all 0.15s;
    }
    .examples-toggle:hover {
      color: #71717a;
      background: #fafaf9;
    }
    .examples-toggle .collapse-icon {
      font-size: var(--font-icon);
      transition: transform 0.2s;
    }
    .examples-toggle .collapse-icon.expanded {
      transform: rotate(90deg);
    }
    .app-layout {
      display: flex;
      flex: 1;
    }
    .left-panel {
      width: var(--sidebar-w);
      min-width: var(--sidebar-w);
      background: white;
      border-right: var(--sp-px) solid #e4e4e7;
      padding: var(--sp-sm);
      overflow-y: auto;
      max-height: calc(100vh - var(--tabs-height));
      position: sticky;
      top: 0;
    }
    .right-panel {
      flex: 1;
      padding: var(--sp-md);
      overflow-y: auto;
    }
    h1 {
      font-weight: 300;
      color: #3f3f46;
      margin-bottom: var(--sp-5xs);
      font-size: var(--font-h1);
    }
    .subtitle {
      font-size: var(--font-tertiary);
      color: #71717a;
      margin-bottom: var(--sp-sm);
    }
    .section {
      margin-bottom: var(--sp-sm);
    }
    .section-title {
      font-size: var(--font-small);
      font-weight: 600;
      color: #71717a;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: var(--sp-4xs);
    }
    .layout-section {
      background: #fafaf9;
      padding: var(--sp-2xs);
      border-radius: var(--radius-md);
      margin-bottom: var(--sp-xs);
    }
    .layout-section .section-title {
      margin-bottom: var(--sp-3xs);
    }
    .subsection {
      margin-bottom: var(--sp-3xs);
    }
    .subsection:last-child {
      margin-bottom: 0;
    }
    .subsection-label {
      font-size: var(--font-tiny);
      color: #a1a1aa;
      margin-bottom: var(--sp-5xs);
    }
    .toggle-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .collapsible-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
    }
    .collapse-icon {
      font-size: var(--font-small);
      color: #a1a1aa;
      transition: transform 0.2s;
    }
    .collapse-icon.expanded {
      transform: rotate(90deg);
    }
    .collapsible-content {
      margin-top: var(--sp-3xs);
    }
    .display-toggles {
      display: flex;
      flex-wrap: wrap;
      gap: var(--sp-3xs);
      margin-bottom: var(--sp-xs);
      padding-bottom: var(--sp-xs);
      border-bottom: var(--sp-px) solid #e4e4e7;
    }
    .display-toggle {
      display: flex;
      align-items: center;
      gap: var(--sp-5xs);
      font-size: var(--font-tertiary);
      color: #52525b;
      cursor: pointer;
    }
    .display-toggle input {
      margin: 0;
    }
    input[type="text"] {
      width: 100%;
      padding: var(--sp-3xs) var(--sp-2xs);
      border: var(--sp-px) solid #e4e4e7;
      border-radius: var(--radius-sm);
      font-size: var(--font-primary);
      outline: none;
    }
    input[type="text"]:focus {
      border-color: #a1a1aa;
    }
    .toggle-group {
      display: flex;
      flex-wrap: wrap;
      gap: var(--sp-5xs);
    }
    .toggle-btn {
      padding: var(--sp-5xs) var(--sp-3xs);
      border: var(--sp-px) solid #e4e4e7;
      border-radius: var(--radius-xs);
      background: white;
      font-size: var(--font-tertiary);
      color: #52525b;
      cursor: pointer;
      transition: all 0.15s;
    }
    .toggle-btn:hover {
      border-color: #a1a1aa;
    }
    .toggle-btn.active {
      background: #3f3f46;
      color: white;
      border-color: #3f3f46;
    }
    .info {
      font-size: var(--font-small);
      color: #a1a1aa;
      font-family: monospace;
      margin-top: var(--sp-4xs);
      padding: var(--sp-4xs);
      background: #fafaf9;
      border-radius: var(--radius-xs);
    }
    label {
      display: flex;
      align-items: center;
      gap: var(--sp-4xs);
      font-size: var(--font-secondary);
      color: #52525b;
      cursor: pointer;
    }
    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: var(--sp-4xs);
    }
    .results-section {
      margin-bottom: var(--sp-lg);
    }
    .results-section-title {
      font-size: var(--font-section);
      font-weight: 500;
      color: #3f3f46;
      margin-bottom: var(--sp-xs);
      padding-bottom: var(--sp-3xs);
      border-bottom: var(--sp-px) solid #e4e4e7;
    }
    .results-subsection {
      display: inline-flex;
      flex-direction: column;
      margin-right: var(--sp-sm);
      margin-bottom: var(--sp-sm);
      vertical-align: top;
    }
    .results-subsection-title {
      font-size: var(--font-tertiary);
      color: #a1a1aa;
      margin-bottom: var(--sp-3xs);
      font-weight: 500;
    }
    .subsections-container {
      display: flex;
      flex-wrap: wrap;
      gap: var(--sp-3xs);
    }
    .results-grid {
      display: flex;
      flex-wrap: wrap;
      gap: var(--sp-2xs);
    }
    .sigil-card-wrapper {
      position: relative;
      display: inline-block;
    }
    .sigil-card-wrapper.stacked-2::before {
      content: '';
      position: absolute;
      top: var(--sp-5xs);
      left: var(--sp-5xs);
      right: calc(var(--sp-5xs) * -1);
      bottom: calc(var(--sp-5xs) * -1);
      background: #e4e4e7;
      border-radius: var(--radius-lg);
      z-index: -1;
    }
    .sigil-card-wrapper.stacked-3::before {
      content: '';
      position: absolute;
      top: var(--sp-5xs);
      left: var(--sp-5xs);
      right: calc(var(--sp-5xs) * -1);
      bottom: calc(var(--sp-5xs) * -1);
      background: #e4e4e7;
      border-radius: var(--radius-lg);
      z-index: -1;
    }
    .sigil-card-wrapper.stacked-3::after {
      content: '';
      position: absolute;
      top: var(--sp-3xs);
      left: var(--sp-3xs);
      right: calc(var(--sp-3xs) * -1);
      bottom: calc(var(--sp-3xs) * -1);
      background: #d4d4d8;
      border-radius: var(--radius-lg);
      z-index: -2;
    }
    .sigil-card-wrapper.stacked-many::before {
      content: '';
      position: absolute;
      top: var(--sp-5xs);
      left: var(--sp-5xs);
      right: calc(var(--sp-5xs) * -1);
      bottom: calc(var(--sp-5xs) * -1);
      background: #e4e4e7;
      border-radius: var(--radius-lg);
      z-index: -1;
    }
    .sigil-card-wrapper.stacked-many::after {
      content: '';
      position: absolute;
      top: var(--sp-3xs);
      left: var(--sp-3xs);
      right: calc(var(--sp-3xs) * -1);
      bottom: calc(var(--sp-3xs) * -1);
      background: #d4d4d8;
      border-radius: var(--radius-lg);
      z-index: -2;
    }
    .stack-count {
      position: absolute;
      top: calc(var(--sp-4xs) * -1);
      right: calc(var(--sp-4xs) * -1);
      background: #3f3f46;
      color: white;
      font-size: var(--font-tiny);
      font-weight: 600;
      width: var(--badge-size);
      height: var(--badge-size);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    .sigil-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: white;
      padding: var(--sp-xs);
      border-radius: var(--radius-lg);
      box-shadow: 0 var(--sp-px) var(--radius-2xs) rgba(0,0,0,0.1);
      transition: all 0.2s;
      position: relative;
    }
    .sigil-card.perfect {
      box-shadow: 0 0 0 var(--radius-2xs) #22c55e, 0 var(--sp-px) var(--radius-2xs) rgba(0,0,0,0.1);
    }
    .sigil-card.favorite {
      box-shadow: 0 0 0 var(--radius-2xs) #3b82f6, 0 0 var(--sp-xs) rgba(59, 130, 246, 0.4);
    }
    .sigil-card.favorite.perfect {
      box-shadow: 0 0 0 var(--radius-2xs) #3b82f6, 0 0 var(--sp-xs) rgba(59, 130, 246, 0.4);
    }
    .sigil-card:hover {
      cursor: pointer;
      transform: translateY(calc(var(--sp-6xs) * -1));
    }
    .sigil-card-hidden {
      width: var(--sp-3xs);
      background: linear-gradient(to right, #e4e4e7, #d4d4d8);
      border-radius: var(--radius-xs);
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      box-shadow: var(--sp-px) 0 var(--sp-6xs) rgba(0,0,0,0.1);
    }
    .sigil-card-hidden:hover {
      width: var(--sp-xs);
      background: linear-gradient(to right, #d4d4d8, #a1a1aa);
    }
    .sigil-card-hidden::after {
      content: '+';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: var(--font-small);
      color: #71717a;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .sigil-card-hidden:hover::after {
      opacity: 1;
    }
    .hide-btn {
      position: absolute;
      top: var(--sp-5xs);
      left: var(--sp-5xs);
      font-size: var(--font-small);
      padding: var(--sp-6xs) var(--sp-4xs);
      background: rgba(0,0,0,0.05);
      border: none;
      border-radius: var(--radius-xs);
      cursor: pointer;
      color: #a1a1aa;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .sigil-card:hover .hide-btn {
      opacity: 1;
    }
    .hide-btn:hover {
      background: rgba(0,0,0,0.1);
      color: #71717a;
    }
    .sigil-card:hover .fav-btn,
    .sigil-card:hover .showcase-btn {
      opacity: 1 !important;
    }
    .showcase-btn.active {
      opacity: 1 !important;
    }
    .favorites-tab {
      background: #eff6ff;
      border: var(--sp-px) solid #bfdbfe;
      border-radius: var(--radius-md);
      padding: var(--sp-sm);
      margin-bottom: var(--sp-sm);
    }
    .favorites-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--sp-xs);
    }
    .favorites-header h3 {
      margin: 0;
      color: #1e40af;
      font-size: var(--font-section);
    }
    .favorites-grid {
      display: flex;
      flex-wrap: wrap;
      gap: var(--sp-xs);
    }
    .favorites-section-label {
      width: 100%;
      font-size: var(--font-tertiary);
      color: #64748b;
      font-weight: 500;
      margin-top: var(--sp-3xs);
      padding-bottom: var(--sp-5xs);
      border-bottom: var(--sp-px) solid #e2e8f0;
    }
    .favorites-section-label:first-child {
      margin-top: 0;
    }
    .export-btn {
      padding: var(--sp-4xs) var(--sp-xs);
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      font-size: var(--font-secondary);
      cursor: pointer;
      transition: background 0.15s;
    }
    .export-btn:hover {
      background: #2563eb;
    }
    .export-btn:disabled {
      background: #93c5fd;
      cursor: not-allowed;
    }
    .clear-favorites-btn {
      padding: var(--sp-4xs) var(--sp-xs);
      background: transparent;
      color: #dc2626;
      border: var(--sp-px) solid #fecaca;
      border-radius: var(--radius-sm);
      font-size: var(--font-secondary);
      cursor: pointer;
      margin-left: var(--sp-3xs);
    }
    .clear-favorites-btn:hover {
      background: #fef2f2;
    }
    .filter-group {
      display: flex;
      gap: var(--sp-5xs);
      flex-wrap: wrap;
    }
    .filter-btn {
      padding: var(--sp-5xs) var(--sp-3xs);
      border: var(--sp-px) solid #e4e4e7;
      border-radius: var(--radius-xs);
      background: white;
      font-size: var(--font-small);
      color: #52525b;
      cursor: pointer;
      transition: all 0.15s;
    }
    .filter-btn:hover {
      border-color: #a1a1aa;
    }
    .filter-btn.active {
      background: #3f3f46;
      color: white;
      border-color: #3f3f46;
    }
    .filter-btn.perfect-filter.active {
      background: #22c55e;
      border-color: #22c55e;
    }
    .sigil-label {
      font-size: var(--font-secondary);
      color: #71717a;
      margin-top: var(--sp-3xs);
      text-align: center;
    }
    .sigil-label.recommended {
      color: #16a34a;
      font-weight: 500;
    }
    .no-results {
      color: #a1a1aa;
      font-size: var(--font-section);
      text-align: center;
      padding: var(--sp-xl);
    }
    .hot-warning {
      color: #ef4444;
    }
    .results-header {
      font-size: var(--font-primary);
      color: #52525b;
      margin-bottom: var(--sp-sm);
      display: flex;
      align-items: center;
      gap: var(--sp-3xs);
    }
    .results-count {
      font-size: var(--font-tertiary);
      color: #a1a1aa;
      font-weight: normal;
    }
    .best-badge {
      background: #16a34a;
      color: white;
      font-size: var(--font-tiny);
      padding: var(--sp-6xs) var(--sp-4xs);
      border-radius: var(--radius-lg);
      font-weight: 500;
    }
    .error-log-container {
      position: relative;
    }
    .error-log-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: var(--sp-3xs);
      z-index: 1000;
      width: var(--error-log-w);
    }
    .error-log-badge {
      background: #ef4444;
      color: white;
      font-size: var(--font-tiny);
      padding: var(--sp-px) calc(var(--sp-5xs) + var(--sp-px));
      border-radius: var(--radius-lg);
      font-weight: 600;
    }
    .error-log-panel {
      margin-top: var(--sp-3xs);
      background: white;
      border: var(--sp-px) solid #e4e4e7;
      border-radius: var(--radius-md);
      box-shadow: 0 var(--sp-5xs) var(--sp-sm) rgba(0,0,0,0.12);
      overflow: hidden;
    }
    .error-log-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--sp-3xs) var(--sp-xs);
      background: #fafaf9;
      border-bottom: var(--sp-px) solid #e4e4e7;
    }
    .error-log-title {
      font-size: var(--font-tertiary);
      font-weight: 600;
      color: #3f3f46;
    }
    .error-log-clear {
      font-size: var(--font-small);
      color: #71717a;
      cursor: pointer;
      padding: var(--sp-6xs) var(--sp-4xs);
      border-radius: var(--radius-2xs);
      transition: all 0.15s;
    }
    .error-log-clear:hover {
      background: #e4e4e7;
      color: #3f3f46;
    }
    .error-log-content {
      max-height: var(--error-list-h);
      overflow-y: auto;
      padding: var(--sp-3xs);
    }
    .error-log-item {
      font-family: monospace;
      font-size: var(--font-small);
      padding: var(--sp-4xs) var(--sp-3xs);
      margin-bottom: var(--sp-5xs);
      border-radius: var(--radius-xs);
      word-break: break-word;
    }
    .error-log-item:last-child {
      margin-bottom: 0;
    }
    .error-log-item.level-error {
      background: #fef2f2;
      color: #7f1d1d;
    }
    .error-log-item.level-warn {
      background: #fefce8;
      color: #854d0e;
    }
    .error-log-item.level-info {
      background: #f0fdf4;
      color: #166534;
    }
    .log-level-badge {
      display: inline-block;
      font-size: var(--font-icon);
      padding: var(--sp-px) var(--sp-5xs);
      border-radius: var(--radius-2xs);
      margin-right: var(--sp-5xs);
      font-weight: 600;
      text-transform: uppercase;
    }
    .log-level-badge.error { background: #ef4444; color: white; }
    .log-level-badge.warn { background: #eab308; color: white; }
    .log-level-badge.info { background: #22c55e; color: white; }
    .error-log-timestamp {
      color: #a1a1aa;
      margin-right: var(--sp-4xs);
    }
    .error-log-empty {
      font-size: var(--font-tertiary);
      color: #a1a1aa;
      text-align: center;
      padding: var(--sp-sm);
    }

    /* Dark mode */
    .dark-mode {
      background: #1a1a1a;
      color: #e4e4e7;
    }
    .dark-mode .tabs-bar {
      background: #262626;
      border-color: #3f3f46;
    }
    .dark-mode .tab {
      color: #a1a1aa;
    }
    .dark-mode .tab:hover {
      color: #e4e4e7;
      background: #3f3f46;
    }
    .dark-mode .tab.active {
      color: #e4e4e7;
      border-bottom-color: #e4e4e7;
    }
    .dark-mode .left-panel {
      background: #262626;
      border-color: #3f3f46;
    }
    .dark-mode .right-panel {
      background: #1a1a1a;
    }
    .dark-mode .sigil-card {
      background: #262626;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    .dark-mode .sigil-card svg {
      background: #1f1f1f !important;
    }
    .dark-mode .results-section-title {
      color: #e4e4e7;
      border-color: #3f3f46;
    }
    .dark-mode .favorites-tab {
      background: #1e3a5f;
      border-color: #2563eb;
    }
    .dark-mode .favorites-header h3 {
      color: #93c5fd;
    }
    .dark-mode input {
      background: #3f3f46;
      border-color: #52525b;
      color: #e4e4e7;
    }
    .dark-mode .section-title, .dark-mode h1 {
      color: #e4e4e7;
    }
    .dark-mode .toggle-btn {
      background: #27272a;
      color: #a1a1aa;
      border-color: #3f3f46;
    }
    .dark-mode .toggle-btn:hover {
      border-color: #71717a;
      background: #3f3f46;
    }
    .dark-mode .toggle-btn.active {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }
    .dark-mode .info {
      color: #a1a1aa;
      background: #27272a;
    }
    .dark-mode label {
      color: #a1a1aa;
    }
    .dark-mode .sigil-card-hidden {
      background: linear-gradient(to right, #3f3f46, #52525b);
    }
    .dark-mode .favorites-section-label {
      color: #94a3b8;
      border-color: #3f3f46;
    }
    .dark-mode .layout-section {
      background: #27272a;
    }
    .dark-mode .subsection-label {
      color: #71717a;
    }
    .dark-mode .filter-btn {
      background: #3f3f46;
      border-color: #52525b;
      color: #a1a1aa;
    }
    .dark-mode .filter-btn:hover {
      border-color: #71717a;
    }
    .dark-mode .filter-btn.active {
      background: #52525b;
      border-color: #52525b;
      color: white;
    }

    /* Detail/Showcase panel */
    .detail-panel {
      width: 50%;
      min-width: var(--detail-min);
      background: white;
      border-left: var(--sp-px) solid #e4e4e7;
      padding: var(--sp-xs);
      overflow-y: auto;
      max-height: calc(100vh - var(--tabs-height));
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: width 0.3s, min-width 0.3s, padding 0.3s;
    }
    .detail-panel.collapsed {
      width: var(--sp-xl);
      min-width: var(--sp-xl);
      padding: var(--sp-3xs);
      cursor: pointer;
    }
    .detail-panel.collapsed:hover {
      background: #f5f5f4;
    }
    .detail-panel-collapsed-label {
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: var(--font-secondary);
      color: #71717a;
      letter-spacing: var(--sp-px);
    }
    .dark-mode .detail-panel {
      background: #262626;
      border-color: #3f3f46;
    }
    .dark-mode .detail-panel.collapsed:hover {
      background: #3f3f46;
    }
    .detail-panel.showcase-dark {
      background: #1a1a1a;
      border-color: #3f3f46;
    }
    .detail-panel.showcase-dark .detail-panel-empty {
      color: #71717a;
    }
    .detail-panel.showcase-dark .detail-panel-collapsed-label {
      color: #a1a1aa;
    }
    .detail-panel-header {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--sp-3xs);
      padding-bottom: var(--sp-3xs);
      border-bottom: var(--sp-px) solid #e4e4e7;
    }
    .detail-panel.showcase-dark .detail-panel-header {
      border-color: #3f3f46;
    }
    .detail-panel-title {
      font-size: var(--font-secondary);
      font-weight: 500;
      color: #3f3f46;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .detail-panel.showcase-dark .detail-panel-title {
      color: #a1a1aa;
    }
    .detail-panel-controls {
      display: flex;
      gap: var(--sp-3xs);
      align-items: center;
    }
    .detail-panel-btn {
      background: none;
      border: var(--sp-px) solid #e4e4e7;
      border-radius: var(--radius-xs);
      padding: var(--sp-5xs) var(--sp-3xs);
      font-size: var(--font-tertiary);
      color: #71717a;
      cursor: pointer;
      transition: all 0.15s;
    }
    .detail-panel-btn:hover {
      border-color: #a1a1aa;
      color: #3f3f46;
    }
    .detail-panel.showcase-dark .detail-panel-btn {
      border-color: #52525b;
      color: #a1a1aa;
    }
    .detail-panel.showcase-dark .detail-panel-btn:hover {
      border-color: #71717a;
      color: #e4e4e7;
    }
    .detail-panel-btn.active {
      background: #3f3f46;
      color: white;
      border-color: #3f3f46;
    }
    .detail-panel.showcase-dark .detail-panel-btn.active {
      background: #e4e4e7;
      color: #1a1a1a;
      border-color: #e4e4e7;
    }
    .detail-panel-btn.print-btn {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
      font-weight: 500;
    }
    .detail-panel-btn.print-btn:hover {
      background: #2563eb;
      border-color: #2563eb;
    }
    .detail-panel-empty {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #a1a1aa;
      font-size: var(--font-primary);
      text-align: center;
      padding: var(--sp-md);
      flex: 1;
    }
    .detail-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
    }
    .showcase-scaled-wrapper {
      transform: scale(0.8) translateY(5%);
      transform-origin: center center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .detail-sigil-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .detail-phrase-arch {
      position: relative;
      width: var(--header-width);
      display: flex;
      justify-content: center;
      color: #52525b;
    }
    .detail-phrase-arch svg {
      overflow: visible;
    }
    .detail-phrase-arch text {
      font-family: 'Didot', 'Bodoni MT', 'Playfair Display', 'Times New Roman', serif;
      font-weight: 300;
      fill: #52525b;
    }
    .detail-phrase-arch path {
      stroke: #52525b;
    }
    .detail-panel.showcase-dark .detail-phrase-arch {
      color: #a1a1aa;
    }
    .detail-panel.showcase-dark .detail-phrase-arch text {
      fill: #a1a1aa;
    }
    .detail-panel.showcase-dark .detail-phrase-arch path {
      stroke: #a1a1aa;
    }
    /* Print mode header - white in dark mode */
    .detail-panel.showcase-dark .detail-content.print-mode .detail-phrase-arch {
      color: #ffffff;
    }
    .detail-panel.showcase-dark .detail-content.print-mode .detail-phrase-arch text {
      fill: #ffffff;
      stroke: #ffffff;
    }
    .detail-panel.showcase-dark .detail-content.print-mode .detail-phrase-arch path {
      stroke: #ffffff;
    }
    .detail-main-sigil {
      margin-top: calc(var(--sp-md) * -1);
    }
    .three-line-header .detail-main-sigil {
      transform: scale(0.85);
      margin-top: calc(var(--sp-md) * -2);
    }
    .detail-main-sigil svg,
    .detail-mini-card svg {
      background: transparent !important;
    }
    .detail-divider {
      width: var(--base);
      height: var(--sp-px);
      background: #e4e4e7;
      margin: var(--sp-sm) 0 var(--sp-xs) 0;
    }
    .detail-panel.showcase-dark .detail-divider {
      background: #3f3f46;
    }
    .detail-info-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }
    .detail-mini-row {
      display: flex;
      justify-content: space-between;
      width: 100%;
      margin-bottom: var(--sp-2xs);
    }
    .detail-mini-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
    }
    .detail-mini-label {
      font-size: var(--font-icon);
      color: #a1a1aa;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-top: var(--sp-5xs);
    }
    .detail-letters {
      font-family: 'Georgia', 'Times New Roman', serif;
      font-size: var(--font-section);
      color: #71717a;
      margin-bottom: var(--sp-6xs);
      text-transform: uppercase;
      width: var(--base);
      margin-left: auto;
      margin-right: auto;
      display: flex;
      justify-content: space-between;
    }
    .detail-letters span {
      flex: 1;
      text-align: center;
    }
    .dark-mode .detail-letters {
      color: #a1a1aa;
    }
    .detail-panel.showcase-dark .detail-letters {
      color: #a1a1aa;
    }
    .detail-numbers {
      font-family: 'Georgia', 'Times New Roman', serif;
      font-size: var(--font-tertiary);
      color: #a1a1aa;
      width: var(--base);
      margin-left: auto;
      margin-right: auto;
      display: flex;
      justify-content: space-between;
    }
    .detail-numbers span {
      flex: 1;
      text-align: center;
    }
    .dark-mode .detail-numbers {
      color: #71717a;
    }
    .detail-panel.showcase-dark .detail-numbers {
      color: #71717a;
    }
    /* Print mode styles - thicker everything, scaled down to fit */
    .detail-content.print-mode .showcase-scaled-wrapper {
      transform: scale(0.58) translateY(-12%);
    }
    .detail-content.print-mode .detail-divider {
      height: 5px;
      background: #1a1a1a;
    }
    .detail-content.print-mode .detail-letters {
      font-weight: 900;
      font-size: calc(var(--font-section) * 2.2);
      color: #1a1a1a;
    }
    .detail-content.print-mode .detail-numbers {
      font-weight: 900;
      font-size: calc(var(--font-tertiary) * 2.2);
      color: #1a1a1a;
    }
    .detail-content.print-mode .detail-mini-label {
      font-weight: 900;
      font-size: calc(var(--font-small) * 1.8);
      color: #1a1a1a;
    }
    .detail-content.print-mode .detail-mini-row {
      overflow: visible;
      padding-top: 16px;
    }
    .detail-content.print-mode .detail-mini-card {
      overflow: visible;
    }
    .detail-content.print-mode .detail-mini-card svg {
      overflow: visible;
      border-radius: 0 !important;
    }
    .detail-content.print-mode .detail-info-section {
      overflow: visible;
    }
    .detail-content.print-mode .showcase-scaled-wrapper {
      overflow: visible;
    }
    .detail-content.print-mode .detail-main-sigil {
      transform: scale(0.82);
      margin-top: calc(var(--sp-md) * -2);
      margin-bottom: calc(var(--sp-xs) * -1);
      overflow: visible;
    }
    .detail-content.print-mode .detail-main-sigil svg {
      overflow: visible;
      border-radius: 0 !important;
    }
    /* Print mode in dark showcase - white text */
    .detail-panel.showcase-dark .detail-content.print-mode .detail-divider {
      background: #ffffff;
    }
    .detail-panel.showcase-dark .detail-content.print-mode .detail-letters {
      color: #ffffff;
    }
    .detail-panel.showcase-dark .detail-content.print-mode .detail-numbers {
      color: #ffffff;
    }
    .detail-panel.showcase-dark .detail-content.print-mode .detail-mini-label {
      color: #ffffff;
    }
    .detail-close {
      position: absolute;
      top: var(--sp-3xs);
      right: var(--sp-3xs);
      background: none;
      border: none;
      font-size: var(--font-h1);
      cursor: pointer;
      color: #a1a1aa;
      padding: var(--sp-5xs) var(--sp-3xs);
    }
    .detail-close:hover {
      color: #3f3f46;
    }
    .dark-mode .detail-close:hover {
      color: #e4e4e7;
    }
    .dark-mode .topbar-toggle {
      background: #3f3f46;
      border-color: #52525b;
      color: #a1a1aa;
    }
    .dark-mode .topbar-toggle:hover {
      background: #52525b;
      border-color: #71717a;
      color: #e4e4e7;
    }
    .dark-mode .topbar-toggle.has-errors {
      background: #7f1d1d;
      border-color: #991b1b;
      color: #fecaca;
    }
    .dark-mode .error-log-panel {
      background: #262626;
      border-color: #3f3f46;
    }
    .dark-mode .error-log-header {
      background: #1f1f1f;
      border-color: #3f3f46;
    }
    .dark-mode .error-log-title {
      color: #e4e4e7;
    }
    .dark-mode .error-log-clear {
      color: #a1a1aa;
    }
    .dark-mode .error-log-clear:hover {
      background: #3f3f46;
      color: #e4e4e7;
    }

    /* Hide mobile elements on desktop */
    .mobile-header {
      display: none;
    }
    .mobile-input-section {
      display: none;
    }
    .mobile-floating-buttons {
      display: none;
    }
    .mobile-controls-toggle {
      display: none;
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      :root {
        --base: min(440px, 92vw);
        --mobile-header-h: 44px;
        --mobile-input-h: 70px;
        --mobile-footer-h: 50px;
      }

      body {
        padding-top: calc(var(--mobile-header-h) + var(--mobile-input-h));
        padding-bottom: var(--mobile-footer-h);
      }

      /* Fixed header at very top */
      .mobile-header {
        display: flex;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: var(--mobile-header-h);
        z-index: 92;
        background: white;
        border-bottom: 1px solid #e4e4e7;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px;
      }

      .dark-mode .mobile-header {
        background: #1f1f1f;
        border-color: #3f3f46;
      }

      .mobile-header-title {
        font-size: 14px;
        font-weight: 500;
        color: #3f3f46;
      }

      .dark-mode .mobile-header-title {
        color: #e4e4e7;
      }

      .mobile-header-btn {
        background: none;
        border: none;
        font-size: 18px;
        padding: 8px;
        cursor: pointer;
        position: relative;
      }

      .mobile-badge {
        position: absolute;
        top: 2px;
        right: 2px;
        background: #ef4444;
        color: white;
        font-size: 10px;
        min-width: 16px;
        height: 16px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* Fixed input below header */
      .mobile-input-section {
        display: block;
        position: fixed;
        top: var(--mobile-header-h);
        left: 0;
        right: 0;
        z-index: 91;
        padding: 10px 12px;
        background: white;
        border-bottom: 1px solid #e4e4e7;
      }

      .dark-mode .mobile-input-section {
        background: #262626;
        border-color: #3f3f46;
      }

      .mobile-input-section input[type="text"] {
        width: 100%;
        font-size: 16px;
        padding: 10px 12px;
        border: 1px solid #d4d4d8;
        border-radius: 8px;
        background: #fafaf9;
      }

      .dark-mode .mobile-input-section input[type="text"] {
        background: #3f3f46;
        border-color: #52525b;
        color: #e4e4e7;
      }

      .mobile-input-info {
        margin-top: 6px;
        font-size: 11px;
        color: #71717a;
        font-family: monospace;
      }

      /* Floating buttons at bottom */
      .mobile-floating-buttons {
        display: flex;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: var(--mobile-footer-h);
        z-index: 92;
        background: white;
        border-top: 1px solid #e4e4e7;
      }

      .dark-mode .mobile-floating-buttons {
        background: #1f1f1f;
        border-color: #3f3f46;
      }

      .mobile-floating-btn {
        flex: 1;
        border: none;
        background: transparent;
        font-size: 14px;
        color: #52525b;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .mobile-floating-btn:first-child {
        border-right: 1px solid #e4e4e7;
      }

      .dark-mode .mobile-floating-btn:first-child {
        border-color: #3f3f46;
      }

      .mobile-floating-btn.active {
        background: #f5f5f4;
        color: #18181b;
      }

      .dark-mode .mobile-floating-btn {
        color: #a1a1aa;
      }

      .dark-mode .mobile-floating-btn.active {
        background: #3f3f46;
        color: #e4e4e7;
      }

      /* Hide tabs bar on mobile */
      .tabs-bar {
        display: none;
      }

      .app-layout {
        flex-direction: column;
      }

      /* Hide left panel on mobile - use floating panel */
      .left-panel {
        display: none;
      }

      /* Floating controls panel */
      .left-panel.mobile-open {
        display: block;
        position: fixed;
        top: calc(var(--mobile-header-h) + var(--mobile-input-h));
        left: 0;
        right: 0;
        bottom: var(--mobile-footer-h);
        width: 100%;
        min-width: unset;
        z-index: 90;
        background: white;
        border: none;
        overflow-y: auto;
        padding: 12px;
      }

      .dark-mode .left-panel.mobile-open {
        background: #262626;
      }

      .left-panel.mobile-open h1 {
        display: none;
      }

      .left-panel .section:first-of-type {
        display: none;
      }

      .right-panel {
        padding: 12px;
      }

      .results-grid {
        justify-content: center;
      }

      .sigil-card {
        padding: 8px;
      }

      /* Showcase panel - collapsed: hide (use button) */
      .detail-panel.collapsed {
        display: none;
      }

      /* Showcase panel - expanded */
      .detail-panel:not(.collapsed) {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        min-width: unset;
        max-height: 100vh;
        overflow-y: auto;
        z-index: 100;
        border-radius: 0;
        border: none;
      }

      .detail-content {
        padding: 16px;
        padding-top: 50px;
      }

      .detail-close {
        position: fixed;
        top: 12px;
        right: 12px;
        background: rgba(255,255,255,0.95);
        border-radius: 6px;
        padding: 8px 14px;
        z-index: 101;
        font-size: 16px;
      }

      .dark-mode .detail-close,
      .detail-panel.showcase-dark .detail-close {
        background: rgba(39, 39, 42, 0.95);
        color: #e4e4e7;
      }

      .showcase-scaled-wrapper {
        transform: scale(0.78) translateY(-3%);
      }

      .detail-content {
        padding: 6px;
        padding-top: 40px;
      }

      .info {
        font-size: 10px;
        word-break: break-all;
      }

      .toggle-group {
        gap: 4px;
      }

      .toggle-btn {
        padding: 4px 6px;
        font-size: 11px;
      }

      .section-title {
        font-size: 10px;
      }

      .filter-btn {
        padding: 4px 8px;
        font-size: 11px;
      }

      .error-log-panel {
        position: fixed;
        top: var(--mobile-header-h);
        left: 12px;
        right: 12px;
        width: auto;
        max-height: 60vh;
        z-index: 95;
      }
    }

    /* Print styles - hide everything except showcase content */
    @media print {
      body, html {
        margin: 0 !important;
        padding: 0 !important;
        background: white !important;
      }
      /* Hide non-showcase elements */
      .sidebar, .controls-toggle, .tabs-bar,
      .mobile-header, .mobile-floating-buttons,
      .detail-panel-header, .detail-close,
      .sigil-results, .error-log {
        display: none !important;
      }
      /* Reset containers */
      .app-container {
        display: block !important;
        padding: 0 !important;
      }
      .main-area {
        display: block !important;
        padding: 0 !important;
        overflow: visible !important;
      }
      .tab-content {
        display: block !important;
      }
      .generate-tab {
        display: block !important;
        padding: 0 !important;
      }
      /* Style the detail panel for print */
      .detail-panel {
        position: static !important;
        width: 100% !important;
        min-width: unset !important;
        max-width: 100% !important;
        border: none !important;
        padding: 20px !important;
        overflow: visible !important;
        max-height: none !important;
        display: block !important;
      }
      .detail-panel.collapsed {
        display: none !important;
      }
      .detail-content {
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
      }
      .showcase-scaled-wrapper {
        transform: none !important;
      }
      .detail-content.print-mode .showcase-scaled-wrapper {
        transform: scale(0.75) !important;
        transform-origin: top center !important;
      }
      @page {
        margin: 0.5cm;
        size: auto;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState } = React;

    // Heat map configuration
    const HEAT_CONFIG = {
      gridSize: 6,        // 6x6 grid (~33px cells for 200px canvas)
      cellThreshold: 2,   // 2+ intersections = warm cell
      zoneThreshold: 2,   // severity sum to trigger alternatives (lowered for more sensitivity)
    };

    // Responsive size configuration - all sizes relative to BASE_SIZE (440px = 1.0)
    const BASE_SIZE = 440;
    const SIZE_RATIOS = {
      // Display sizes
      header: 1.0,          // Same as sigil width
      detailMin: 0.909,     // 400px
      genSize: 0.455,       // 200px - internal generation size
      cardDisplay: 0.382,   // 168px - grid card size
      favDisplay: 0.341,    // 150px - favorite display default
      chainedGen: 1.364,    // 600px - chained generation
      chainedDisplay: 0.682, // 300px - chained card display
      exportSize: 0.909,    // 400px - export resolution
      miniDisplay: 0.295,   // 130px - mini preview cards
      // Spacing
      spMd: 0.045,          // 20px
      spSm: 0.036,          // 16px
      spXs: 0.027,          // 12px
      sp2xs: 0.023,         // 10px
      sp3xs: 0.018,         // 8px
      sp4xs: 0.014,         // 6px
      sp5xs: 0.009,         // 4px
      sp6xs: 0.005,         // 2px
      // Font sizes
      fontSecondary: 0.027, // 12px
      fontTertiary: 0.025,  // 11px
      fontSmall: 0.023,     // 10px
      fontTiny: 0.020,      // 9px
      // Border radius
      radiusMd: 0.018,      // 8px
      radius2xs: 0.007,     // 3px
    };

    // Calculate actual sizes from ratios
    const getSize = (ratio) => Math.round(BASE_SIZE * ratio);

    // Layout modes
    const LayoutMode = {
      STANDARD: 'standard',
      VENN: 'venn',
      EXTRA_RINGS: 'extra_rings',
      SATELLITE: 'satellite',
      CHAINED: 'chained',
    };

    // Grid-based heat map analysis
    const analyzeHeatMap = (intersections, size, gridSize = HEAT_CONFIG.gridSize) => {
      const cellSize = size / gridSize;
      const cells = [];

      // Initialize grid
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          cells.push({
            x: x * cellSize,
            y: y * cellSize,
            gridX: x,
            gridY: y,
            count: 0,
            intersections: []
          });
        }
      }

      // Count intersections per cell
      for (const int of intersections) {
        const gridX = Math.min(gridSize - 1, Math.floor(int.x / cellSize));
        const gridY = Math.min(gridSize - 1, Math.floor(int.y / cellSize));
        const cellIdx = gridY * gridSize + gridX;
        cells[cellIdx].count++;
        cells[cellIdx].intersections.push(int);
      }

      // Find warm cells (count >= threshold)
      const warmCells = cells.filter(c => c.count >= HEAT_CONFIG.cellThreshold);

      // Flood-fill to find connected hot zones
      const visited = new Set();
      const zones = [];

      const getNeighbors = (cell) => {
        const neighbors = [];
        const { gridX, gridY } = cell;
        for (const [dx, dy] of [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [1,-1], [-1,1], [1,1]]) {
          const nx = gridX + dx;
          const ny = gridY + dy;
          if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
            const neighbor = warmCells.find(c => c.gridX === nx && c.gridY === ny);
            if (neighbor) neighbors.push(neighbor);
          }
        }
        return neighbors;
      };

      for (const cell of warmCells) {
        const key = `${cell.gridX},${cell.gridY}`;
        if (visited.has(key)) continue;

        // BFS flood-fill
        const zone = [];
        const queue = [cell];

        while (queue.length > 0) {
          const curr = queue.shift();
          const currKey = `${curr.gridX},${curr.gridY}`;
          if (visited.has(currKey)) continue;
          visited.add(currKey);
          zone.push(curr);

          for (const neighbor of getNeighbors(curr)) {
            const nKey = `${neighbor.gridX},${neighbor.gridY}`;
            if (!visited.has(nKey)) queue.push(neighbor);
          }
        }

        if (zone.length > 0) {
          // Calculate zone center and severity
          const totalCount = zone.reduce((sum, c) => sum + c.count, 0);
          const centerX = zone.reduce((sum, c) => sum + (c.x + cellSize/2) * c.count, 0) / totalCount;
          const centerY = zone.reduce((sum, c) => sum + (c.y + cellSize/2) * c.count, 0) / totalCount;
          const radius = Math.max(...zone.map(c =>
            Math.hypot(c.x + cellSize/2 - centerX, c.y + cellSize/2 - centerY)
          )) + cellSize;

          zones.push({
            centerX,
            centerY,
            radius,
            severity: totalCount,
            cells: zone
          });
        }
      }

      const globalScore = zones.reduce((sum, z) => sum + z.severity, 0);
      const isHot = globalScore >= HEAT_CONFIG.zoneThreshold;

      return { isHot, globalScore, zones, cells, cellSize };
    };

    const processText = (text) => {
      const words = text.toLowerCase().split(/\s+/);
      const noVowels = words.map(w => w.replace(/[aeiou]/g, ''));
      const allChars = noVowels.join('');
      const unique = [...new Set(allChars.split(''))].filter(c => c.match(/[a-z]/));
      const numbers = unique.map(c => c.charCodeAt(0) - 96);
      return { words, noVowels, unique, numbers };
    };

    // Split characters into groups for chained rings layout
    // Each group must have at least 2 characters (minimum for a valid ring)
    // Uses balanced splitting to avoid tiny trailing groups
    // Split characters into groups for chained rings
    // lockedGroups: previously assigned groups to preserve (for "locking" behavior)
    const splitIntoGroups = (unique, numbers, maxPerGroup = 5, lockedGroups = null) => {
      const n = unique.length;

      // Need at least 2 characters total for any valid sigil
      if (n < 2) {
        return [];
      }

      // If we have locked groups, try to preserve them
      if (lockedGroups && lockedGroups.length > 0) {
        // Count how many characters are in locked groups
        const lockedCount = lockedGroups.reduce((sum, g) => sum + g.unique.length, 0);

        // Check if the locked characters are still the prefix of our unique list
        let lockedCharsMatch = true;
        let checkIdx = 0;
        for (const group of lockedGroups) {
          for (const char of group.unique) {
            if (checkIdx >= unique.length || unique[checkIdx] !== char) {
              lockedCharsMatch = false;
              break;
            }
            checkIdx++;
          }
          if (!lockedCharsMatch) break;
        }

        // If locked chars still match, preserve them and only split new chars
        if (lockedCharsMatch && lockedCount <= n) {
          const newChars = unique.slice(lockedCount);
          const newNumbers = numbers.slice(lockedCount);

          if (newChars.length === 0) {
            // No new characters, return locked groups as-is
            return lockedGroups.map(g => ({ ...g }));
          }

          // We have new characters to add
          const lastLocked = lockedGroups[lockedGroups.length - 1];
          const lastLockedSize = lastLocked.unique.length;

          // If last locked group has room, add to it first
          if (lastLockedSize < maxPerGroup) {
            const canAdd = maxPerGroup - lastLockedSize;
            const toAdd = Math.min(canAdd, newChars.length);

            // Create result with preserved groups
            const result = lockedGroups.slice(0, -1).map(g => ({ ...g }));

            // Expand last group
            result.push({
              unique: [...lastLocked.unique, ...newChars.slice(0, toAdd)],
              numbers: [...lastLocked.numbers, ...newNumbers.slice(0, toAdd)]
            });

            // If there are still more chars, create new groups for them
            if (toAdd < newChars.length) {
              const remainingChars = newChars.slice(toAdd);
              const remainingNumbers = newNumbers.slice(toAdd);
              const newGroups = splitIntoGroups(remainingChars, remainingNumbers, maxPerGroup, null);
              result.push(...newGroups);
            }

            return result;
          } else {
            // Last group is full, create new groups for new chars
            const result = lockedGroups.map(g => ({ ...g }));
            const newGroups = splitIntoGroups(newChars, newNumbers, maxPerGroup, null);
            result.push(...newGroups);
            return result;
          }
        }
        // If locked chars don't match (chars were deleted), fall through to recalculate
      }

      // No locking or chars were deleted - calculate fresh
      // Simply fill rings sequentially to capacity - no redistribution
      // Even if last ring has only 1 char, that's fine (it's a partial/growing ring)
      const groups = [];
      let idx = 0;

      while (idx < n) {
        const remaining = n - idx;
        const takeNow = Math.min(maxPerGroup, remaining);

        groups.push({
          unique: unique.slice(idx, idx + takeNow),
          numbers: numbers.slice(idx, idx + takeNow)
        });
        idx += takeNow;
      }

      return groups;
    };

    // Generate points for a single ring (used by chained rings layout)
    // rotation parameter allows rotating the ring so a specific point lands at a desired position
    const generateSingleRingPoints = (unique, numbers, radius, cx, cy, groupId, rotation = 0) => {
      const points = [];
      const count = unique.length;

      for (let i = 0; i < count; i++) {
        const angle = (2 * Math.PI * i) / count - Math.PI / 2 + rotation;
        points.push({
          letter: unique[i],
          number: numbers[i],
          index: i,
          ringIndex: 0,
          positionInRing: i,
          ringTotal: count,
          radius,
          x: cx + radius * Math.cos(angle),
          y: cy + radius * Math.sin(angle),
          angle,
          group: groupId,
          circleCx: cx,
          circleCy: cy
        });
      }
      return { points, cx, cy, radius };
    };

    // Find valid attachment points along line segments and arcs for connecting new rings
    // Always returns midpoints of paths - simpler and more reliable
    const findAttachmentPoints = (pathData, ringData, sortedPoints) => {
      const candidates = [];
      let lineCount = 0, arcCount = 0, skippedShort = 0;

      for (let pathIdx = 0; pathIdx < pathData.length; pathIdx++) {
        const path = pathData[pathIdx];
        const { from, to } = path;

        if (path.type === 'line') {
          const lineLen = Math.hypot(to.x - from.x, to.y - from.y);
          if (lineLen < 5) {
            skippedShort++;
            continue;
          }
          lineCount++;

          const lineAngle = Math.atan2(to.y - from.y, to.x - from.x);

          // Sample many points along line to ensure we find zero-intersection positions
          // More points = more options to find non-overlapping positions
          const samplePoints = lineLen > 40 ? [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9] :
                               lineLen > 20 ? [0.15, 0.3, 0.45, 0.55, 0.7, 0.85] :
                               lineLen > 10 ? [0.25, 0.5, 0.75] : [0.5];
          for (const t of samplePoints) {
            const px = from.x + t * (to.x - from.x);
            const py = from.y + t * (to.y - from.y);
            candidates.push({ x: px, y: py, lineAngle, pathIndex: pathIdx, t, pathType: 'line' });
          }
        } else if (path.type === 'arc' && path.radius) {
          arcCount++;
          const cx = from.circleCx;
          const cy = from.circleCy;
          const r = path.radius;

          const angleFrom = Math.atan2(from.y - cy, from.x - cx);
          const angleTo = Math.atan2(to.y - cy, to.x - cx);

          let angleDiff = angleTo - angleFrom;
          if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
          if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

          // Sample many points along arc to ensure we find zero-intersection positions
          const arcLen = Math.abs(angleDiff) * r;
          const samplePoints = arcLen > 40 ? [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9] :
                               arcLen > 20 ? [0.15, 0.3, 0.45, 0.55, 0.7, 0.85] :
                               arcLen > 10 ? [0.25, 0.5, 0.75] : [0.5];
          for (const t of samplePoints) {
            const angle = angleFrom + t * angleDiff;
            const x = cx + r * Math.cos(angle);
            const y = cy + r * Math.sin(angle);
            const tangentAngle = angle + Math.PI / 2;
            candidates.push({ x, y, lineAngle: tangentAngle, pathIndex: pathIdx, t, pathType: 'arc' });
          }
        }
      }

      console.log(`[Chained] findAttachmentPoints: ${lineCount} lines, ${arcCount} arcs, ${skippedShort} skipped (too short)  ${candidates.length} candidates`);
      return candidates;
    };

    // Check if two line segments intersect
    const lineSegmentsIntersect = (x1, y1, x2, y2, x3, y3, x4, y4) => {
      const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (Math.abs(denom) < 0.0001) return false; // Parallel

      const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
      const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

      // Check if intersection point is within both segments (with small margin to avoid endpoint touches)
      return t > 0.05 && t < 0.95 && u > 0.05 && u < 0.95;
    };

    // Check if a line segment intersects with an arc
    // Arc defined by center (cx, cy), radius r, and angle range [angleStart, angleEnd]
    const lineArcIntersect = (x1, y1, x2, y2, cx, cy, r, angleStart, angleEnd) => {
      // Line segment as parametric: P = (x1,y1) + t*(x2-x1, y2-y1), t in [0,1]
      const dx = x2 - x1;
      const dy = y2 - y1;

      // Solve for intersection with circle: |P - C|^2 = r^2
      const fx = x1 - cx;
      const fy = y1 - cy;

      const a = dx * dx + dy * dy;
      const b = 2 * (fx * dx + fy * dy);
      const c = fx * fx + fy * fy - r * r;

      const discriminant = b * b - 4 * a * c;
      if (discriminant < 0) return false; // No intersection with circle

      const sqrtDisc = Math.sqrt(discriminant);
      const t1 = (-b - sqrtDisc) / (2 * a);
      const t2 = (-b + sqrtDisc) / (2 * a);

      // Check each intersection point
      for (const t of [t1, t2]) {
        // Must be within line segment (with margin to avoid endpoints)
        if (t < 0.05 || t > 0.95) continue;

        // Calculate intersection point
        const ix = x1 + t * dx;
        const iy = y1 + t * dy;

        // Check if point is within arc's angle range
        let angle = Math.atan2(iy - cy, ix - cx);

        // Normalize angles to handle wraparound
        let start = angleStart, end = angleEnd;
        if (end < start) {
          // Arc crosses 0/2 boundary
          if (angle < start) angle += 2 * Math.PI;
          end += 2 * Math.PI;
        }

        // Check if angle is within arc range (with small margin)
        const margin = 0.1; // ~6 degrees
        if (angle >= start + margin && angle <= end - margin) {
          return true;
        }
      }
      return false;
    };

    // Predict where points would be for a ring at given position
    const predictRingPoints = (cx, cy, radius, pointCount, rotation) => {
      const points = [];
      for (let i = 0; i < pointCount; i++) {
        const angle = (2 * Math.PI * i) / pointCount - Math.PI / 2 + rotation;
        points.push({
          x: cx + radius * Math.cos(angle),
          y: cy + radius * Math.sin(angle),
          positionInRing: i
        });
      }
      return points;
    };

    // Convert any path (line or arc) to a series of line segments for uniform intersection checking
    const pathToLineSegments = (path, numSamples = 8) => {
      const segments = [];
      const { from, to } = path;

      if (path.type === 'arc' && path.radius && from.circleCx !== undefined) {
        // Sample arc as multiple line segments
        const cx = from.circleCx;
        const cy = from.circleCy;
        const r = path.radius;
        const angleStart = Math.atan2(from.y - cy, from.x - cx);
        const angleEnd = Math.atan2(to.y - cy, to.x - cx);

        let angleDiff = angleEnd - angleStart;
        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        for (let i = 0; i < numSamples; i++) {
          const t1 = i / numSamples;
          const t2 = (i + 1) / numSamples;
          const a1 = angleStart + t1 * angleDiff;
          const a2 = angleStart + t2 * angleDiff;
          segments.push({
            x1: cx + r * Math.cos(a1), y1: cy + r * Math.sin(a1),
            x2: cx + r * Math.cos(a2), y2: cy + r * Math.sin(a2)
          });
        }
      } else {
        // Straight line - just one segment
        segments.push({ x1: from.x, y1: from.y, x2: to.x, y2: to.y });
      }

      return segments;
    };

    // Count how many path intersections a new ring would create with existing paths
    const countPathIntersections = (newCx, newCy, newRadius, newNumbers, rotation, existingPathData) => {
      const pointCount = newNumbers.length;
      if (pointCount < 2) return 0;

      // Predict new ring's points
      const newPoints = predictRingPoints(newCx, newCy, newRadius, pointCount, rotation);

      // Sort by number value to get path order
      const sortedIndices = newNumbers.map((n, idx) => ({ n, idx })).sort((a, b) => a.n - b.n);

      // Determine which paths would be arcs vs lines (same logic as generateRingPathData)
      const newSegments = [];
      let lastWasArc = false;
      for (let i = 0; i < sortedIndices.length - 1; i++) {
        const fromIdx = sortedIndices[i].idx;
        const toIdx = sortedIndices[i + 1].idx;
        const fromPt = newPoints[fromIdx];
        const toPt = newPoints[toIdx];

        // Check if adjacent on ring
        const diff = Math.abs(fromPt.positionInRing - toPt.positionInRing);
        const adjacent = diff === 1 || diff === pointCount - 1;
        const canBeArc = adjacent && pointCount > 3 && !lastWasArc;

        if (canBeArc) {
          // This would be an arc - sample it
          const angleStart = Math.atan2(fromPt.y - newCy, fromPt.x - newCx);
          const angleEnd = Math.atan2(toPt.y - newCy, toPt.x - newCx);
          let angleDiff = angleEnd - angleStart;
          if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
          if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

          const numSamples = 8;
          for (let s = 0; s < numSamples; s++) {
            const t1 = s / numSamples;
            const t2 = (s + 1) / numSamples;
            const a1 = angleStart + t1 * angleDiff;
            const a2 = angleStart + t2 * angleDiff;
            newSegments.push({
              x1: newCx + newRadius * Math.cos(a1), y1: newCy + newRadius * Math.sin(a1),
              x2: newCx + newRadius * Math.cos(a2), y2: newCy + newRadius * Math.sin(a2)
            });
          }
          lastWasArc = true;
        } else {
          // Straight line
          newSegments.push({ x1: fromPt.x, y1: fromPt.y, x2: toPt.x, y2: toPt.y });
          lastWasArc = false;
        }
      }

      // Convert existing paths to line segments
      const existingSegments = [];
      for (const existingRingPaths of existingPathData) {
        if (!existingRingPaths || !existingRingPaths.pathData) continue;
        for (const existingPath of existingRingPaths.pathData) {
          existingSegments.push(...pathToLineSegments(existingPath));
        }
      }

      // Count intersections using uniform line-line check
      let intersectionCount = 0;
      for (const newSeg of newSegments) {
        for (const existSeg of existingSegments) {
          if (lineSegmentsIntersect(newSeg.x1, newSeg.y1, newSeg.x2, newSeg.y2,
                                     existSeg.x1, existSeg.y1, existSeg.x2, existSeg.y2)) {
            intersectionCount++;
          }
        }
      }

      return intersectionCount;
    };

    // Simple check: new ring's center must be outside previous rings
    // NOTE: This function is essentially deprecated for chained layouts.
    // Rings MUST overlap to connect - we only care about LINE intersections.
    // This is kept for edge cases but should NOT block ring placement.
    const checkRingOverlap = (newCx, newCy, newRadius, existingRings, margin = 0) => {
      // Always return no overlap - ring overlap is DESIRED for connection
      return { overlaps: false, severity: 0 };
    };

    // Position a new ring so that its start vertex lands exactly ON a line segment of the previous ring
    // This ensures the rings are visually connected
    // preferDirection: 'down-right' or 'down-left' - alternates per ring
    // existingPathData: array of path data from previous rings, used to check for line intersections
    const positionNewRing = (attachmentCandidates, ringRadius, existingRings, canvasSize, newRingNumbers, preferDirection = 'down-right', existingPathData = []) => {
      if (attachmentCandidates.length === 0) return null;

      const newRingPointCount = newRingNumbers.length;

      // Find which position index has the lowest number (this will be the path start)
      const sortedIndices = newRingNumbers.map((n, idx) => ({ n, idx })).sort((a, b) => a.n - b.n);
      const startPositionIdx = sortedIndices[0].idx;

      // The start point's angle on the ring (before any rotation)
      // Position i is placed at angle: (2 * i / count) - /2
      const startAngleBase = (2 * Math.PI * startPositionIdx) / newRingPointCount - Math.PI / 2;

      // Rotation angles to try - every 5 degrees = 72 positions
      const rotations = [];
      for (let r = 0; r < Math.PI * 2; r += Math.PI / 36) {
        rotations.push(r);
      }

      // Target angle for direction preference
      // For center DOWN-RIGHT of attach: angle around 5/4 (225)
      // For center DOWN-LEFT of attach: angle around 7/4 (315)
      const targetAngle = preferDirection === 'down-left' ? Math.PI * 1.75 : Math.PI * 1.25;

      // Collect ALL valid positions and score them
      const validPositions = [];
      const zeroIntersectionPositions = []; // Positions with NO line intersections

      for (const attach of attachmentCandidates) {
        for (const rotation of rotations) {
          const startAngleFinal = startAngleBase + rotation;
          const newCx = attach.x - ringRadius * Math.cos(startAngleFinal);
          const newCy = attach.y - ringRadius * Math.sin(startAngleFinal);

          // Check bounds - be lenient since centering code will adjust final positions
          // Allow rings to extend slightly beyond canvas (will be centered later)
          const boundMargin = -ringRadius * 0.3; // Allow 30% of ring to extend beyond
          if (newCx - ringRadius < boundMargin || newCx + ringRadius > canvasSize - boundMargin ||
              newCy - ringRadius < boundMargin || newCy + ringRadius > canvasSize - boundMargin) continue;

          // Check center overlap
          const overlap = checkRingOverlap(newCx, newCy, ringRadius, existingRings, 0);
          if (overlap.overlaps) continue;

          // Count path intersections with existing paths
          const intersections = countPathIntersections(newCx, newCy, ringRadius, newRingNumbers, startAngleFinal, existingPathData);

          // Calculate direction score based on where the ring CENTER is relative to the ATTACHMENT point
          const dx = newCx - attach.x;
          const dy = newCy - attach.y;
          const actualAngle = Math.atan2(dy, dx);

          // Target angles: down-right = /4 (45), down-left = 3/4 (135)
          const targetDirectionAngle = preferDirection === 'down-right' ? Math.PI / 4 : Math.PI * 3 / 4;

          let angleDiff = Math.abs(actualAngle - targetDirectionAngle);
          if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
          const directionScore = 1 - (angleDiff / Math.PI);

          // Position bonus: prefer rings that are actually down and in the preferred x direction
          const isDown = dy > 0 ? 1 : 0;
          const isCorrectX = (preferDirection === 'down-right' && dx > 0) ||
                             (preferDirection === 'down-left' && dx < 0) ? 1 : 0;

          // SPREAD SCORE: Prefer positions that maximize distance from existing ring centers
          // This prevents clustering by favoring positions that spread the chain out
          let minDistToExisting = Infinity;
          for (const existingRing of existingRings) {
            const dist = Math.hypot(newCx - existingRing.cx, newCy - existingRing.cy);
            minDistToExisting = Math.min(minDistToExisting, dist);
          }
          // Normalize spread score: ideal distance is ~2x ringRadius (touching but not overlapping)
          const idealDist = ringRadius * 2;
          const spreadScore = Math.min(1, minDistToExisting / idealDist);

          // Combined score - spread and direction both matter
          const totalScore = spreadScore * 0.4 + directionScore * 0.35 + isDown * 0.15 + isCorrectX * 0.1;

          const posData = {
            cx: newCx,
            cy: newCy,
            attachPoint: attach,
            connectEnd: 'start',
            rotation,
            connectionX: attach.x,
            connectionY: attach.y,
            score: totalScore,
            intersections
          };

          validPositions.push(posData);

          // Track zero-intersection positions separately
          if (intersections === 0) {
            zeroIntersectionPositions.push(posData);
          }
        }
      }

      // Prefer positions with NO line intersections
      // If none exist, sort all by intersection count first, then by score
      let preferredPositions;
      if (zeroIntersectionPositions.length > 0) {
        preferredPositions = zeroIntersectionPositions;
        preferredPositions.sort((a, b) => b.score - a.score);
      } else {
        // No zero-intersection positions - sort by intersections first, then by score
        preferredPositions = validPositions;
        preferredPositions.sort((a, b) => {
          // Primary: fewer intersections is better
          if (a.intersections !== b.intersections) {
            return a.intersections - b.intersections;
          }
          // Secondary: higher score is better
          return b.score - a.score;
        });
      }

      if (preferredPositions.length === 0) return null;

      // Take top 5 positions (or fewer if not enough)
      const topN = Math.min(5, preferredPositions.length);
      const topPositions = preferredPositions.slice(0, topN);

      // Use a seed based on ring geometry so position changes when letters are added
      const seed = newRingNumbers.reduce((sum, n) => sum + n, 0) + newRingPointCount * 100;
      const selectedIdx = seed % topN;
      const selected = topPositions[selectedIdx];

      console.log(`[Chained] positionNewRing: ${validPositions.length} valid, ${zeroIntersectionPositions.length} zero-intersection, using top ${topN}, seed=${seed}, idx=${selectedIdx}, intersections=${selected.intersections}`);

      return selected;
    };

    // Generate path data for a single ring's internal paths
    const generateRingPathData = (ringPoints, pointsPerRing) => {
      const sortedByValue = [...ringPoints].sort((a, b) => a.number - b.number);
      const pathData = [];
      let lastWasArc = false; // Track previous segment type for alternation rule

      for (let i = 0; i < sortedByValue.length - 1; i++) {
        const from = sortedByValue[i];
        const to = sortedByValue[i + 1];
        // Check if adjacent on this ring
        const diff = Math.abs(from.positionInRing - to.positionInRing);
        const max = from.ringTotal;
        const adjacent = diff === 1 || diff === max - 1;

        // Rule 1: rings with 3 or fewer characters always use straight lines (no arcs)
        // Rule 2: arcs must alternate with lines (no arcarc)
        const canBeArc = adjacent && from.ringTotal > 3 && !lastWasArc;
        const useArc = canBeArc;

        pathData.push({
          type: useArc ? 'arc' : 'line',
          from, to,
          radius: useArc ? from.radius : null,
          index: i,
          group: from.group
        });

        lastWasArc = useArc;
      }

      return { pathData, sortedPoints: sortedByValue };
    };

    // Chained rings layout: multiple rings connected end-to-end
    // lockedRings: array of locked FULL rings with their positions
    //   Each: { chars, numbers, cx, cy, radius }
    const generateChainedRingsLayout = (unique, numbers, size, pointsPerRing = 5, showJunctionDots = true, lockedRings = null) => {
      // Convert lockedRings to lockedGroups format for splitIntoGroups
      const lockedGroups = lockedRings ? lockedRings.map(r => ({
        unique: r.chars,
        numbers: r.numbers
      })) : null;

      const groups = splitIntoGroups(unique, numbers, pointsPerRing, lockedGroups);
      const cx = size / 2;
      const cy = size / 2;
      const numGroups = groups.length;

      // Debug: log group formation
      console.log(`[Chained] Characters: ${unique.length}, PPR: ${pointsPerRing}, Groups: ${numGroups}${lockedGroups ? ' (locked)' : ''}`,
        groups.map((g, i) => `G${i}:${g.unique.length}`).join(', '));

      // Handle edge case: no groups (empty input)
      if (numGroups === 0 || !groups[0] || groups[0].unique.length === 0) {
        return {
          points: [],
          rings: [],
          ringCenters: [],
          maxRadius: 0,
          junctionDots: [],
          ringPathData: [],
          layout: { mode: 'chained', ringData: [], ringPathData: [] },
          showJunctionDots
        };
      }

      // Ring radius scales based on number of groups to fit all rings
      // More groups = smaller rings to fit within canvas
      const baseRadius = size * 0.12;
      const ringRadius = numGroups <= 2 ? baseRadius :
                         numGroups <= 4 ? size * 0.10 :
                         numGroups <= 6 ? size * 0.08 :
                         size * 0.07;
      const margin = size * 0.04;

      const allPoints = [];
      const ringData = []; // Track each ring's center and radius
      const junctionDots = []; // Optional dots at attachment points
      const ringPathData = []; // Store path data for each ring

      // Helper to check if a group matches a locked ring
      const findLockedRing = (groupChars) => {
        if (!lockedRings) return null;
        return lockedRings.find(lr =>
          lr.chars.length === groupChars.length &&
          lr.chars.every((c, i) => c === groupChars[i])
        );
      };

      // Ring 1: Check if locked, otherwise position more centrally
      // Starting more centrally allows rings to spread in any direction without hitting bounds
      const locked0 = findLockedRing(groups[0].unique);
      const ring1Cx = locked0 ? locked0.cx : size * 0.35;
      const ring1Cy = locked0 ? locked0.cy : size * 0.35;
      const ring1 = generateSingleRingPoints(groups[0].unique, groups[0].numbers, ringRadius, ring1Cx, ring1Cy, 'ring0');

      // Update indices to be global
      ring1.points.forEach((p, idx) => {
        p.globalIndex = idx;
      });

      allPoints.push(...ring1.points);
      ringData.push({ cx: ring1Cx, cy: ring1Cy, radius: ringRadius, groupId: 'ring0', locked: !!locked0 });

      // Generate paths for ring 1 to find attachment points for ring 2
      const ring1PathInfo = generateRingPathData(ring1.points, pointsPerRing);
      ringPathData.push(ring1PathInfo);

      // Debug: Log ring 1 path details
      const pathTypes = ring1PathInfo.pathData.map(p => p.type).join(',');
      console.log(`[Chained] Ring 0 paths: ${ring1PathInfo.pathData.length} segments [${pathTypes}], PPR=${pointsPerRing}`);

      // Rings 2+: Position based on attachment to previous ring
      // The new ring's start vertex will land on a LINE SEGMENT (not vertex) of the previous ring
      for (let i = 1; i < groups.length; i++) {
        // Check if this ring is locked (full ring from previous generation)
        const lockedRing = findLockedRing(groups[i].unique);

        if (lockedRing) {
          // Use locked position for full rings
          console.log(`[Chained] Ring ${i}: Using LOCKED position at (${lockedRing.cx.toFixed(1)}, ${lockedRing.cy.toFixed(1)})`);

          const ring = generateSingleRingPoints(
            groups[i].unique, groups[i].numbers,
            ringRadius, lockedRing.cx, lockedRing.cy,
            `ring${i}`, 0
          );

          const globalOffset = allPoints.length;
          ring.points.forEach((p, idx) => { p.globalIndex = globalOffset + idx; });

          allPoints.push(...ring.points);
          ringData.push({ cx: lockedRing.cx, cy: lockedRing.cy, radius: ringRadius, groupId: `ring${i}`, locked: true });

          const ringPathInfo = generateRingPathData(ring.points, pointsPerRing);
          ringPathData.push(ringPathInfo);

          // Add junction dot at start point
          if (showJunctionDots) {
            const sortedPoints = [...ring.points].sort((a, b) => a.number - b.number);
            junctionDots.push({ x: sortedPoints[0].x, y: sortedPoints[0].y, fromRing: i - 1, toRing: i });
          }

          continue; // Skip to next ring
        }

        // Not locked - calculate position dynamically
        const prevRingInfo = ringPathData[i - 1];
        let attachCandidates = [];
        let prevRingPaths = [];

        if (prevRingInfo && prevRingInfo.pathData && prevRingInfo.pathData.length > 0) {
          prevRingPaths = prevRingInfo.pathData;
          const prevRingSortedPoints = prevRingInfo.sortedPoints;
          attachCandidates = findAttachmentPoints(prevRingPaths, ringData, prevRingSortedPoints);
        } else {
          console.warn(`Chained layout: No path data for ring ${i-1}, will use fallback position`);
        }

        if (attachCandidates.length === 0) {
          console.warn(`Chained layout: No attachment candidates found for ring ${i}, will use fallback position`);
        } else {
          console.log(`[Chained] Ring ${i}: Found ${attachCandidates.length} attachment candidates (unlocked), prefer ${i % 2 === 1 ? 'down-right' : 'down-left'}`);
        }

        // Alternate direction: odd index (ring 2, 4, ...) goes down-right, even index (ring 3, 5, ...) goes down-left
        const preferDirection = i % 2 === 1 ? 'down-right' : 'down-left';

        let position = positionNewRing(attachCandidates, ringRadius, ringData, size, groups[i].numbers, preferDirection, ringPathData);
        if (position) {
          console.log(`[Chained] Ring ${i}: Primary positioning succeeded at (${position.cx.toFixed(1)}, ${position.cy.toFixed(1)}), intersections=${position.intersections}`);
        }

        // FALLBACK 1: Try the opposite direction
        if (!position) {
          const oppositeDirection = preferDirection === 'down-right' ? 'down-left' : 'down-right';
          position = positionNewRing(attachCandidates, ringRadius, ringData, size, groups[i].numbers, oppositeDirection, ringPathData);
          if (position) {
            console.log(`[Chained] Ring ${i}: FALLBACK 1 (opposite direction) succeeded`);
          }
        }

        // FALLBACK 2: Exhaustive search - try ALL rotations on ALL candidates, prefer zero intersections
        if (!position && attachCandidates.length > 0) {
          console.log(`[Chained] Ring ${i}: Trying FALLBACK 2 (exhaustive search)`);
          const newRingNumbers = groups[i].numbers;
          const newRingPointCount = newRingNumbers.length;
          const sortedIndices = newRingNumbers.map((n, idx) => ({ n, idx })).sort((a, b) => a.n - b.n);
          const startPositionIdx = sortedIndices[0].idx;
          const startAngleBase = (2 * Math.PI * startPositionIdx) / newRingPointCount - Math.PI / 2;

          const allRotations = [];
          for (let r = 0; r < Math.PI * 2; r += Math.PI / 36) {
            allRotations.push(r);
          }

          const fallbackCandidates = [];
          for (const attach of attachCandidates) {
            for (const rotation of allRotations) {
              const startAngleFinal = startAngleBase + rotation;
              const newCx = attach.x - ringRadius * Math.cos(startAngleFinal);
              const newCy = attach.y - ringRadius * Math.sin(startAngleFinal);

              // Lenient bounds - centering will adjust final positions
              const boundMargin = -ringRadius * 0.3;
              if (newCx - ringRadius < boundMargin || newCx + ringRadius > size - boundMargin ||
                  newCy - ringRadius < boundMargin || newCy + ringRadius > size - boundMargin) continue;

              const overlap = checkRingOverlap(newCx, newCy, ringRadius, ringData, 0);
              if (overlap.overlaps) continue;

              const intersections = countPathIntersections(newCx, newCy, ringRadius, newRingNumbers, startAngleFinal, ringPathData);
              fallbackCandidates.push({
                cx: newCx, cy: newCy, attachPoint: attach,
                connectEnd: 'start', rotation,
                connectionX: attach.x, connectionY: attach.y,
                intersections
              });
            }
          }

          // Add spread scores to fallback candidates
          for (const cand of fallbackCandidates) {
            let minDist = Infinity;
            for (const existingRing of ringData) {
              const dist = Math.hypot(cand.cx - existingRing.cx, cand.cy - existingRing.cy);
              minDist = Math.min(minDist, dist);
            }
            cand.spreadScore = minDist / (ringRadius * 2);
          }

          // Prefer zero-intersection positions, sorted by spread
          const zeroInt = fallbackCandidates.filter(c => c.intersections === 0);
          if (zeroInt.length > 0) {
            zeroInt.sort((a, b) => b.spreadScore - a.spreadScore);
            position = zeroInt[0];
          } else if (fallbackCandidates.length > 0) {
            fallbackCandidates.sort((a, b) => {
              if (a.intersections !== b.intersections) return a.intersections - b.intersections;
              return b.spreadScore - a.spreadScore;
            });
            position = fallbackCandidates[0];
          }
        }

        // FALLBACK 3: Generate more attachment points along the ENTIRE path
        // Still strictly mid-line only
        if (!position && prevRingPaths.length > 0) {
          const prevRing = ringData[i - 1];
          const newRingNumbers = groups[i].numbers;
          const newRingPointCount = newRingNumbers.length;
          const sortedIndices = newRingNumbers.map((n, idx) => ({ n, idx })).sort((a, b) => a.n - b.n);
          const startPositionIdx = sortedIndices[0].idx;
          const startAngleBase = (2 * Math.PI * startPositionIdx) / newRingPointCount - Math.PI / 2;

          // Generate more attachment points with finer sampling
          const fineCandidates = [];
          for (const path of prevRingPaths) {
            const { from, to } = path;
            if (path.type === 'line') {
              const lineLen = Math.hypot(to.x - from.x, to.y - from.y);
              if (lineLen < 15) continue;
              // Sample at 10 points along line (avoiding endpoints)
              for (let t = 0.1; t <= 0.9; t += 0.1) {
                const x = from.x + t * (to.x - from.x);
                const y = from.y + t * (to.y - from.y);
                fineCandidates.push({ x, y });
              }
            } else if (path.type === 'arc' && path.radius) {
              const arcCx = from.circleCx;
              const arcCy = from.circleCy;
              const r = path.radius;
              const angleFrom = Math.atan2(from.y - arcCy, from.x - arcCx);
              const angleTo = Math.atan2(to.y - arcCy, to.x - arcCx);
              let angleDiff = angleTo - angleFrom;
              if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
              if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
              // Sample at 10 points along arc
              for (let t = 0.1; t <= 0.9; t += 0.1) {
                const angle = angleFrom + t * angleDiff;
                const x = arcCx + r * Math.cos(angle);
                const y = arcCy + r * Math.sin(angle);
                fineCandidates.push({ x, y });
              }
            }
          }

          // Try all fine candidates with all rotations
          const allRotations = [];
          for (let r = 0; r < Math.PI * 2; r += Math.PI / 36) {
            allRotations.push(r);
          }

          const fallback3Candidates = [];
          for (const attach of fineCandidates) {
            for (const rotation of allRotations) {
              const startAngleFinal = startAngleBase + rotation;
              const newCx = attach.x - ringRadius * Math.cos(startAngleFinal);
              const newCy = attach.y - ringRadius * Math.sin(startAngleFinal);

              // Lenient bounds - centering will adjust final positions
              const boundMargin = -ringRadius * 0.3;
              if (newCx - ringRadius < boundMargin || newCx + ringRadius > size - boundMargin ||
                  newCy - ringRadius < boundMargin || newCy + ringRadius > size - boundMargin) continue;

              const overlap = checkRingOverlap(newCx, newCy, ringRadius, ringData, 0);
              if (overlap.overlaps) continue;

              const intersections = countPathIntersections(newCx, newCy, ringRadius, newRingNumbers, startAngleFinal, ringPathData);
              fallback3Candidates.push({
                cx: newCx, cy: newCy, attachPoint: attach,
                connectEnd: 'start', rotation,
                connectionX: attach.x, connectionY: attach.y,
                intersections
              });
            }
          }

          // Add spread scores to fallback3 candidates
          for (const cand of fallback3Candidates) {
            let minDist = Infinity;
            for (const existingRing of ringData) {
              const dist = Math.hypot(cand.cx - existingRing.cx, cand.cy - existingRing.cy);
              minDist = Math.min(minDist, dist);
            }
            cand.spreadScore = minDist / (ringRadius * 2);
          }

          // Prefer zero-intersection positions, sorted by spread
          const zeroInt3 = fallback3Candidates.filter(c => c.intersections === 0);
          if (zeroInt3.length > 0) {
            zeroInt3.sort((a, b) => b.spreadScore - a.spreadScore);
            position = zeroInt3[0];
          } else if (fallback3Candidates.length > 0) {
            fallback3Candidates.sort((a, b) => {
              if (a.intersections !== b.intersections) return a.intersections - b.intersections;
              return b.spreadScore - a.spreadScore;
            });
            position = fallback3Candidates[0];
          }
        }

        // LAST RESORT: If still no valid position found, just place it below/right of previous ring
        // NOTE: This creates a DISCONNECTED ring - no attachment point on previous ring's path
        if (!position) {
          const prevRing = ringData[i - 1];
          // Use larger offsets that spread rings in a zigzag pattern going down
          const spreadDist = ringRadius * 2.2; // Slightly more than diameter for clear separation
          const offsetX = (i % 2 === 1) ? spreadDist : -spreadDist * 0.6;
          const offsetY = spreadDist * 0.9; // Mostly downward
          position = {
            cx: prevRing.cx + offsetX,
            cy: prevRing.cy + offsetY,
            attachPoint: { x: prevRing.cx + offsetX * 0.5, y: prevRing.cy + offsetY * 0.5 },
            connectEnd: 'start',
            rotation: 0,
            connectionX: prevRing.cx + offsetX * 0.5,
            connectionY: prevRing.cy + offsetY * 0.5
          };
          console.warn(`[Chained] Ring ${i}: LAST RESORT - ring will NOT be connected! PPR=${pointsPerRing}`);
        }

        const ring = generateSingleRingPoints(
          groups[i].unique, groups[i].numbers,
          ringRadius, position.cx, position.cy,
          `ring${i}`,
          position.rotation || 0
        );

        // Update global indices
        const globalOffset = allPoints.length;
        ring.points.forEach((p, idx) => {
          p.globalIndex = globalOffset + idx;
        });

        allPoints.push(...ring.points);
        ringData.push({
          cx: position.cx, cy: position.cy, radius: ringRadius, groupId: `ring${i}`,
          connectEnd: position.connectEnd, attachPoint: position.attachPoint
        });

        // Generate path data for this ring
        const ringPathInfo = generateRingPathData(ring.points, pointsPerRing);
        ringPathData.push(ringPathInfo);

        // Junction dot is at the ACTUAL start point of this ring (where it connects to prev ring)
        // The start point is the one with the lowest number value
        if (showJunctionDots) {
          const sortedPoints = [...ring.points].sort((a, b) => a.number - b.number);
          const startPoint = sortedPoints[0]; // Point with lowest number = path start
          junctionDots.push({
            x: startPoint.x,
            y: startPoint.y,
            fromRing: i - 1,
            toRing: i
          });
        }
      }

      // Center the entire chain in the canvas
      // Calculate bounding box of all rings (including their radius)
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const ring of ringData) {
        minX = Math.min(minX, ring.cx - ring.radius);
        maxX = Math.max(maxX, ring.cx + ring.radius);
        minY = Math.min(minY, ring.cy - ring.radius);
        maxY = Math.max(maxY, ring.cy + ring.radius);
      }

      // Calculate offset to center in canvas
      const boundingCenterX = (minX + maxX) / 2;
      const boundingCenterY = (minY + maxY) / 2;
      const canvasCenterX = size / 2;
      const canvasCenterY = size / 2;
      const offsetX = canvasCenterX - boundingCenterX;
      const offsetY = canvasCenterY - boundingCenterY;

      // Apply offset to all points
      for (const point of allPoints) {
        point.x += offsetX;
        point.y += offsetY;
        point.circleCx += offsetX;
        point.circleCy += offsetY;
      }

      // Apply offset to ring centers
      for (const ring of ringData) {
        ring.cx += offsetX;
        ring.cy += offsetY;
        if (ring.attachPoint) {
          ring.attachPoint.x += offsetX;
          ring.attachPoint.y += offsetY;
        }
      }

      // Apply offset to junction dots
      for (const dot of junctionDots) {
        dot.x += offsetX;
        dot.y += offsetY;
      }

      // Regenerate path data with new positions
      ringPathData.length = 0;
      for (let i = 0; i < ringData.length; i++) {
        const ringPoints = allPoints.filter(p => p.group === `ring${i}`);
        const ringPathInfo = generateRingPathData(ringPoints, pointsPerRing);
        ringPathData.push(ringPathInfo);
      }

      // Calculate tight content bounds (after centering) for viewBox optimization
      let contentMinX = Infinity, contentMaxX = -Infinity;
      let contentMinY = Infinity, contentMaxY = -Infinity;
      for (const ring of ringData) {
        contentMinX = Math.min(contentMinX, ring.cx - ring.radius);
        contentMaxX = Math.max(contentMaxX, ring.cx + ring.radius);
        contentMinY = Math.min(contentMinY, ring.cy - ring.radius);
        contentMaxY = Math.max(contentMaxY, ring.cy + ring.radius);
      }
      // Add padding for markers and strokes
      const contentPadding = 15;
      const contentBounds = {
        x: contentMinX - contentPadding,
        y: contentMinY - contentPadding,
        width: (contentMaxX - contentMinX) + contentPadding * 2,
        height: (contentMaxY - contentMinY) + contentPadding * 2
      };

      return {
        points: allPoints,
        rings: ringData.map(r => r.radius),
        ringCenters: ringData,
        maxRadius: ringRadius,
        junctionDots,
        ringPathData,
        groups, // Include groups for locking
        layout: { mode: 'chained', ringData, ringPathData, groups },
        showJunctionDots,
        contentBounds
      };
    };

    const isAdjacentOnRing = (p1, p2, pointsPerRing) => {
      if (p1.ringIndex !== p2.ringIndex) return false;
      // Prevent arcs across different groups (venn/satellite layouts)
      if (p1.group && p2.group && p1.group !== p2.group) return false;
      const diff = Math.abs(p1.positionInRing - p2.positionInRing);
      const max = Math.min(pointsPerRing, p1.ringTotal);
      return diff === 1 || diff === max - 1;
    };

    const seededRandom = (seed) => {
      const x = Math.sin(seed * 9999) * 10000;
      return x - Math.floor(x);
    };

    // Interior angle at vertex (0-180, where 0 = hairpin, 180 = straight)
    const calculateVertexAngle = (prev, curr, next) => {
      const v1x = prev.x - curr.x;
      const v1y = prev.y - curr.y;
      const v2x = next.x - curr.x;
      const v2y = next.y - curr.y;

      const len1 = Math.hypot(v1x, v1y);
      const len2 = Math.hypot(v2x, v2y);

      if (len1 === 0 || len2 === 0) return 180;

      const dot = (v1x / len1) * (v2x / len2) + (v1y / len1) * (v2y / len2);
      const angleRad = Math.acos(Math.max(-1, Math.min(1, dot)));
      return angleRad * (180 / Math.PI);
    };

    // 0 = parallel, 90 = perpendicular
    const calculateCrossingAngle = (line1From, line1To, line2From, line2To) => {
      const d1x = line1To.x - line1From.x;
      const d1y = line1To.y - line1From.y;
      const d2x = line2To.x - line2From.x;
      const d2y = line2To.y - line2From.y;

      const len1 = Math.hypot(d1x, d1y);
      const len2 = Math.hypot(d2x, d2y);

      if (len1 === 0 || len2 === 0) return 45;

      const dot = Math.abs((d1x / len1) * (d2x / len2) + (d1y / len1) * (d2y / len2));
      const angleRad = Math.acos(Math.min(1, dot));
      return angleRad * (180 / Math.PI);
    };

    const lineLineIntersection = (p1, p2, p3, p4) => {
      const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;
      const x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;

      const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (Math.abs(denom) < 0.001) return null;

      const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
      const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

      if (t > 0.08 && t < 0.92 && u > 0.08 && u < 0.92) {
        return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1), t };
      }
      return null;
    };

    const lineArcIntersection = (lineFrom, lineTo, arcFrom, arcTo, cx, cy, radius) => {
      const steps = 24;
      const angle1 = Math.atan2(arcFrom.y - cy, arcFrom.x - cx);
      let angle2 = Math.atan2(arcTo.y - cy, arcTo.x - cx);

      let angleDiff = angle2 - angle1;
      while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
      while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

      for (let i = 0; i < steps; i++) {
        const t1 = i / steps;
        const t2 = (i + 1) / steps;
        const a1 = angle1 + angleDiff * t1;
        const a2 = angle1 + angleDiff * t2;

        const p1 = { x: cx + Math.cos(a1) * radius, y: cy + Math.sin(a1) * radius };
        const p2 = { x: cx + Math.cos(a2) * radius, y: cy + Math.sin(a2) * radius };

        const int = lineLineIntersection(lineFrom, lineTo, p1, p2);
        if (int) return { x: int.x, y: int.y };
      }
      return null;
    };

    const getArcPoint = (arcFrom, arcTo, cx, cy, radius, t) => {
      const angle1 = Math.atan2(arcFrom.y - cy, arcFrom.x - cx);
      let angle2 = Math.atan2(arcTo.y - cy, arcTo.x - cx);

      let angleDiff = angle2 - angle1;
      while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
      while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

      const angle = angle1 + angleDiff * t;
      return { x: cx + Math.cos(angle) * radius, y: cy + Math.sin(angle) * radius };
    };

    const getArcLength = (arcFrom, arcTo, cx, cy, radius) => {
      const angle1 = Math.atan2(arcFrom.y - cy, arcFrom.x - cx);
      const angle2 = Math.atan2(arcTo.y - cy, arcTo.x - cx);

      let angleDiff = Math.abs(angle2 - angle1);
      if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;

      return angleDiff * radius;
    };

    const arcPathD = (p1, p2, cx, cy, radius) => {
      const angle1 = Math.atan2(p1.y - cy, p1.x - cx);
      const angle2 = Math.atan2(p2.y - cy, p2.x - cx);
      let angleDiff = angle2 - angle1;

      while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
      while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

      const sweep = angleDiff > 0 ? 1 : 0;
      return `M ${p1.x} ${p1.y} A ${radius} ${radius} 0 0 ${sweep} ${p2.x} ${p2.y}`;
    };

    const closestPointOnSegment = (pt, segA, segB) => {
      const dx = segB.x - segA.x;
      const dy = segB.y - segA.y;
      const lenSq = dx * dx + dy * dy;

      if (lenSq === 0) return segA;

      let t = ((pt.x - segA.x) * dx + (pt.y - segA.y) * dy) / lenSq;
      t = Math.max(0, Math.min(1, t));

      return { x: segA.x + t * dx, y: segA.y + t * dy };
    };

    // Calculate the incoming angle at a path endpoint
    // For arcs: use tangent direction (perpendicular to radius)
    // For lines: use direction from previous point to endpoint
    const getIncomingAngle = (lastPath, lastPoint, secondLastPoint) => {
      if (lastPath && lastPath.type === 'arc' && lastPath.radius && lastPoint.circleCx !== undefined) {
        // For arc: tangent is perpendicular to radius at endpoint
        const arcCx = lastPoint.circleCx;
        const arcCy = lastPoint.circleCy;
        const radiusAngle = Math.atan2(lastPoint.y - arcCy, lastPoint.x - arcCx);
        // Determine arc direction by checking if we're going clockwise or counterclockwise
        const fromAngle = Math.atan2(lastPath.from.y - arcCy, lastPath.from.x - arcCx);
        const toAngle = Math.atan2(lastPath.to.y - arcCy, lastPath.to.x - arcCx);
        let angleDiff = toAngle - fromAngle;
        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        // Tangent is perpendicular to radius, direction depends on arc direction
        return radiusAngle + (angleDiff > 0 ? Math.PI / 2 : -Math.PI / 2);
      } else {
        // For straight line: direction from second-last to last point
        return Math.atan2(lastPoint.y - secondLastPoint.y, lastPoint.x - secondLastPoint.x);
      }
    };

    const getBarCollisionDistance = (endPoint, perpAngle, barLen, pathData, cx, cy, lastPathIndex) => {
      const bar1 = { x: endPoint.x + Math.cos(perpAngle) * barLen, y: endPoint.y + Math.sin(perpAngle) * barLen };
      const bar2 = { x: endPoint.x - Math.cos(perpAngle) * barLen, y: endPoint.y - Math.sin(perpAngle) * barLen };

      let minDist = Infinity;

      for (let i = 0; i < pathData.length; i++) {
        const p = pathData[i];
        if (i === lastPathIndex) continue;

        if (p.type === 'line') {
          const int = lineLineIntersection(bar1, bar2, p.from, p.to);
          if (int) {
            const dist = Math.hypot(int.x - endPoint.x, int.y - endPoint.y);
            minDist = Math.min(minDist, dist);
          }

          for (const barEnd of [bar1, bar2]) {
            const closestOnLine = closestPointOnSegment(barEnd, p.from, p.to);
            const d = Math.hypot(barEnd.x - closestOnLine.x, barEnd.y - closestOnLine.y);
            if (d < 4) minDist = Math.min(minDist, d);
          }
        } else if (p.type === 'arc') {
          const arcCx = p.from.circleCx ?? cx;
          const arcCy = p.from.circleCy ?? cy;
          const int = lineArcIntersection(bar1, bar2, p.from, p.to, arcCx, arcCy, p.radius);
          if (int) {
            const dist = Math.hypot(int.x - endPoint.x, int.y - endPoint.y);
            minDist = Math.min(minDist, dist);
          }
        }
      }

      return minDist;
    };

    // Standard layout: concentric rings
    const generateStandardLayout = (unique, numbers, size, pointsPerRing, cx, cy) => {
      const n = unique.length;
      const numRings = Math.ceil(n / pointsPerRing);
      const maxRadius = size * 0.42;
      const minRadius = maxRadius / (1 + (numRings - 1) / 2);
      const ringGap = minRadius / 2;

      const rings = [];
      for (let i = 0; i < numRings; i++) {
        rings.push(maxRadius - i * ringGap);
      }

      const points = unique.map((letter, i) => {
        const ringIndex = Math.floor(i / pointsPerRing);
        const positionInRing = i % pointsPerRing;
        const radius = rings[ringIndex];

        const startOfRing = ringIndex * pointsPerRing;
        const endOfRing = Math.min(startOfRing + pointsPerRing, n);
        const ringTotal = endOfRing - startOfRing;

        const angle = (positionInRing / ringTotal) * Math.PI * 2 - Math.PI / 2;

        return {
          letter, number: numbers[i], index: i, ringIndex, positionInRing, ringTotal, radius,
          x: cx + Math.cos(angle) * radius,
          y: cy + Math.sin(angle) * radius,
          angle,
          group: 'main',
          circleCx: cx,
          circleCy: cy
        };
      });

      return { points, rings, maxRadius };
    };

    // Venn layout: two or three overlapping circles
    const generateVennLayout = (unique, numbers, size, pointsPerRing, cx, cy, circleCount = 2) => {
      const n = unique.length;
      const margin = size * 0.05;

      if (circleCount === 3) {
        // RGB-style triangular arrangement
        const availableSize = size - 2 * margin;
        const maxRadius = availableSize * 0.28;
        const offset = maxRadius * 0.7;

        // Three circle centers in equilateral triangle
        const centers = [
          { x: cx, y: cy - offset * 0.7, group: 'top' },
          { x: cx - offset * 0.85, y: cy + offset * 0.5, group: 'left' },
          { x: cx + offset * 0.85, y: cy + offset * 0.5, group: 'right' },
        ];

        const perCircle = Math.ceil(n / 3);
        const rings = [maxRadius];
        const points = [];

        centers.forEach((center, circleIdx) => {
          const startIdx = circleIdx * perCircle;
          const endIdx = Math.min(startIdx + perCircle, n);
          const count = endIdx - startIdx;

          for (let i = 0; i < count; i++) {
            const globalIdx = startIdx + i;
            if (globalIdx >= n) break;
            const angle = (i / count) * Math.PI * 2 - Math.PI / 2;
            points.push({
              letter: unique[globalIdx],
              number: numbers[globalIdx],
              index: globalIdx,
              ringIndex: 0,
              positionInRing: i,
              ringTotal: count,
              radius: maxRadius,
              x: center.x + Math.cos(angle) * maxRadius,
              y: center.y + Math.sin(angle) * maxRadius,
              angle,
              group: center.group,
              circleCx: center.x,
              circleCy: center.y
            });
          }
        });

        return { points, rings, maxRadius, centers, circleCount: 3 };
      }

      // 2-circle Venn
      const availableWidth = size - 2 * margin;
      const maxRadius = availableWidth / 2.4;
      const offset = maxRadius * 0.4;

      const leftCount = Math.ceil(n / 2);
      const rightCount = n - leftCount;

      const leftCx = cx - offset / 2;
      const rightCx = cx + offset / 2;

      const rings = [maxRadius];
      const points = [];

      for (let i = 0; i < leftCount; i++) {
        const angle = (i / leftCount) * Math.PI * 2 - Math.PI / 2;
        points.push({
          letter: unique[i],
          number: numbers[i],
          index: i,
          ringIndex: 0,
          positionInRing: i,
          ringTotal: leftCount,
          radius: maxRadius,
          x: leftCx + Math.cos(angle) * maxRadius,
          y: cy + Math.sin(angle) * maxRadius,
          angle,
          group: 'left',
          circleCx: leftCx,
          circleCy: cy
        });
      }

      for (let i = 0; i < rightCount; i++) {
        const globalIdx = leftCount + i;
        const angle = (i / rightCount) * Math.PI * 2 - Math.PI / 2;
        points.push({
          letter: unique[globalIdx],
          number: numbers[globalIdx],
          index: globalIdx,
          ringIndex: 0,
          positionInRing: i,
          ringTotal: rightCount,
          radius: maxRadius,
          x: rightCx + Math.cos(angle) * maxRadius,
          y: cy + Math.sin(angle) * maxRadius,
          angle,
          group: 'right',
          circleCx: rightCx,
          circleCy: cy
        });
      }

      return { points, rings, maxRadius, leftCx, rightCx, cy: cy, circleCount: 2 };
    };

    // Extra rings layout: more rings with fewer points each
    const generateExtraRingsLayout = (unique, numbers, size, pointsPerRing, cx, cy) => {
      const reducedPointsPerRing = Math.max(3, Math.floor(pointsPerRing * 0.6));
      return generateStandardLayout(unique, numbers, size, reducedPointsPerRing, cx, cy);
    };

    // Satellite layout: main ring + connected smaller ring
    const generateSatelliteLayout = (unique, numbers, size, pointsPerRing, cx, cy) => {
      const n = unique.length;
      const mainCount = Math.ceil(n * 0.7);
      const satCount = n - mainCount;

      // Calculate sizes to fit within canvas
      const margin = size * 0.05;
      const gap = size * 0.03;
      // Total width: mainRadius + mainRadius + gap + satRadius + satRadius = 2*main + gap + 2*sat
      // With sat = 0.5 * main: 2*main + gap + main = 3*main + gap
      // Available = size - 2*margin, so main = (available - gap) / 3
      const availableWidth = size - 2 * margin;
      const mainRadius = (availableWidth - gap) / 3;
      const satRadius = mainRadius * 0.5;
      const satOffset = mainRadius + gap + satRadius;

      const sorted = unique.map((letter, i) => ({ letter, number: numbers[i], origIndex: i }))
        .sort((a, b) => a.number - b.number);

      const mainLetters = sorted.slice(0, mainCount);
      const satLetters = sorted.slice(mainCount);

      const rings = [mainRadius, satRadius];
      const points = [];

      // Shift main ring left so the whole composition is centered
      const mainCx = cx - (gap / 2 + satRadius);

      const mainByOrig = mainLetters.sort((a, b) => a.origIndex - b.origIndex);
      for (let i = 0; i < mainByOrig.length; i++) {
        const { letter, number, origIndex } = mainByOrig[i];
        const angle = (i / mainByOrig.length) * Math.PI * 2 - Math.PI / 2;
        points.push({
          letter, number, index: origIndex,
          ringIndex: 0,
          positionInRing: i,
          ringTotal: mainByOrig.length,
          radius: mainRadius,
          x: mainCx + Math.cos(angle) * mainRadius,
          y: cy + Math.sin(angle) * mainRadius,
          angle,
          group: 'main',
          circleCx: mainCx,
          circleCy: cy
        });
      }

      const satCx = mainCx + satOffset;
      const satByOrig = satLetters.sort((a, b) => a.origIndex - b.origIndex);
      for (let i = 0; i < satByOrig.length; i++) {
        const { letter, number, origIndex } = satByOrig[i];
        const angle = (i / satByOrig.length) * Math.PI * 2 - Math.PI / 2;
        points.push({
          letter, number, index: origIndex,
          ringIndex: 1,
          positionInRing: i,
          ringTotal: satByOrig.length,
          radius: satRadius,
          x: satCx + Math.cos(angle) * satRadius,
          y: cy + Math.sin(angle) * satRadius,
          angle,
          group: 'satellite',
          circleCx: satCx,
          circleCy: cy
        });
      }

      return {
        points,
        rings,
        maxRadius: mainRadius,
        mainCx,
        satCx,
        satCy: cy,
        satRadius,
        mainRadius,
        hasConnector: satCount > 0
      };
    };

    // Generate points based on layout mode
    const generatePoints = (unique, numbers, size, pointsPerRing, layoutMode, cx, cy) => {
      switch (layoutMode) {
        case LayoutMode.VENN:
          return generateVennLayout(unique, numbers, size, pointsPerRing, cx, cy);
        case LayoutMode.EXTRA_RINGS:
          return generateExtraRingsLayout(unique, numbers, size, pointsPerRing, cx, cy);
        case LayoutMode.SATELLITE:
          return generateSatelliteLayout(unique, numbers, size, pointsPerRing, cx, cy);
        default:
          return generateStandardLayout(unique, numbers, size, pointsPerRing, cx, cy);
      }
    };

    // Extended sigil generator with layout options
    const generateSigilWithOptions = (unique, numbers, size, pointsPerRing, layoutType, options = {}) => {
      const cx = size / 2;
      const cy = size / 2;
      const n = unique.length;

      if (n < 2) return { paths: [], markers: [], intersections: [], acuteVertices: [], arcDots: [], cx, cy, rings: [], maxRadius: 0, layoutMode: layoutType, points: [], size };

      let layout;
      if (layoutType === 'venn') {
        layout = generateVennLayout(unique, numbers, size, pointsPerRing, cx, cy, options.circleCount || 2);
      } else if (layoutType === 'satellite') {
        layout = generateSatelliteLayoutExtended(unique, numbers, size, pointsPerRing, cx, cy, options.mainRings || 1, options.satRings || 1);
      } else if (layoutType === 'chained') {
        layout = generateChainedRingsLayout(unique, numbers, size, options.pointsPerRing || 5, options.showJunctionDots !== false, options.lockedRings || null);
        return generateSigilFromChainedLayout(unique, numbers, size, layout, cx, cy);
      } else {
        layout = generateStandardLayout(unique, numbers, size, pointsPerRing, cx, cy);
      }

      // Use the standard sigil generation pipeline with the custom layout
      return generateSigilFromLayout(unique, numbers, size, pointsPerRing, layout, layoutType, cx, cy);
    };

    // Extended Satellite layout with configurable rings
    const generateSatelliteLayoutExtended = (unique, numbers, size, pointsPerRing, cx, cy, mainRingCount = 1, satRingCount = 1) => {
      const n = unique.length;
      const totalRings = mainRingCount + satRingCount;
      const mainRatio = mainRingCount / totalRings;
      const mainCount = Math.ceil(n * mainRatio * 0.8); // Main gets proportionally more
      const satCount = n - mainCount;

      const margin = size * 0.05;
      const gap = size * 0.02;
      const availableWidth = size - 2 * margin;

      // Calculate sizes based on ring counts
      const mainRadius = availableWidth * 0.25;
      const satRadius = mainRadius * 0.6;
      const mainCx = cx - (satRadius + gap) / 2;
      const satCx = mainCx + mainRadius + gap + satRadius;

      const sorted = unique.map((letter, i) => ({ letter, number: numbers[i], origIndex: i }))
        .sort((a, b) => a.number - b.number);

      const mainLetters = sorted.slice(0, mainCount);
      const satLetters = sorted.slice(mainCount);

      const rings = [mainRadius, satRadius];
      const points = [];

      // Main ring points
      const mainByOrig = [...mainLetters].sort((a, b) => a.origIndex - b.origIndex);
      for (let i = 0; i < mainByOrig.length; i++) {
        const { letter, number, origIndex } = mainByOrig[i];
        const angle = (i / mainByOrig.length) * Math.PI * 2 - Math.PI / 2;
        points.push({
          letter, number, index: origIndex,
          ringIndex: 0, positionInRing: i, ringTotal: mainByOrig.length,
          radius: mainRadius,
          x: mainCx + Math.cos(angle) * mainRadius,
          y: cy + Math.sin(angle) * mainRadius,
          angle, group: 'main', circleCx: mainCx, circleCy: cy
        });
      }

      // Satellite ring points
      if (satLetters.length > 0) {
        const satByOrig = [...satLetters].sort((a, b) => a.origIndex - b.origIndex);
        for (let i = 0; i < satByOrig.length; i++) {
          const { letter, number, origIndex } = satByOrig[i];
          const angle = (i / satByOrig.length) * Math.PI * 2 - Math.PI / 2;
          points.push({
            letter, number, index: origIndex,
            ringIndex: 1, positionInRing: i, ringTotal: satByOrig.length,
            radius: satRadius,
            x: satCx + Math.cos(angle) * satRadius,
            y: cy + Math.sin(angle) * satRadius,
            angle, group: 'satellite', circleCx: satCx, circleCy: cy
          });
        }
      }

      return {
        points, rings, maxRadius: mainRadius, mainCx, satCx, satCy: cy,
        satRadius, mainRadius, hasConnector: satCount > 0,
        mainRingCount, satRingCount
      };
    };

    // Generate sigil from a chained rings layout with special marker handling
    const generateSigilFromChainedLayout = (unique, numbers, size, layout, cx, cy) => {
      const { points, rings, maxRadius, ringCenters, junctionDots, ringPathData, showJunctionDots } = layout;
      const n = unique.length;

      if (n < 2) return { paths: [], markers: [], intersections: [], acuteVertices: [], arcDots: [], cx, cy, rings: [], maxRadius: 0, layoutMode: 'chained', layout, points: [], size, junctionDots: [] };

      const numRings = ringCenters.length;
      const allPaths = [];
      const allIntersections = [];
      const allAcuteVertices = [];
      const allArcDots = [];
      const markers = [];
      const seed = unique.reduce((s, c) => s + c.charCodeAt(0), 0);

      // Process each ring separately
      for (let ringIdx = 0; ringIdx < numRings; ringIdx++) {
        const ringPoints = points.filter(p => p.group === `ring${ringIdx}`);
        if (ringPoints.length < 2) continue;

        const ringCenter = ringCenters[ringIdx];
        const sortedRingPoints = [...ringPoints].sort((a, b) => a.number - b.number);

        // Calculate acute vertices for this ring
        for (let i = 1; i < sortedRingPoints.length - 1; i++) {
          const prev = sortedRingPoints[i - 1];
          const curr = sortedRingPoints[i];
          const next = sortedRingPoints[i + 1];
          const vertexAngle = calculateVertexAngle(prev, curr, next);
          if (vertexAngle < 30 || vertexAngle > 150) {
            if (seededRandom(seed + ringIdx * 100 + i * 17) > 0.5) {
              allAcuteVertices.push({ x: curr.x, y: curr.y, angle: vertexAngle, index: i });
            }
          }
        }

        // Generate paths for this ring
        const pathData = [];
        let lastWasArc = false; // Track previous segment type for alternation rule
        for (let i = 0; i < sortedRingPoints.length - 1; i++) {
          const from = sortedRingPoints[i];
          const to = sortedRingPoints[i + 1];
          // Check if adjacent on this ring
          const diff = Math.abs(from.positionInRing - to.positionInRing);
          const max = from.ringTotal;
          const adjacent = diff === 1 || diff === max - 1;

          // Rule 1: rings with 3 or fewer characters always use straight lines (no arcs)
          // Rule 2: arcs must alternate with lines (no arcarc)
          const canBeArc = adjacent && from.ringTotal > 3 && !lastWasArc;
          const useArc = canBeArc;

          pathData.push({
            type: useArc ? 'arc' : 'line',
            from, to,
            radius: useArc ? from.radius : null,
            index: i,
            ringIdx
          });

          lastWasArc = useArc;
        }

        // Find intersections within this ring
        for (let i = 0; i < pathData.length; i++) {
          for (let j = i + 1; j < pathData.length; j++) {
            const p1 = pathData[i];
            const p2 = pathData[j];
            let int = null;
            let crossingAngle = 45;

            if (p1.type === 'line' && p2.type === 'line') {
              int = lineLineIntersection(p1.from, p1.to, p2.from, p2.to);
              if (int) crossingAngle = calculateCrossingAngle(p1.from, p1.to, p2.from, p2.to);
            } else if (p1.type === 'line' && p2.type === 'arc') {
              int = lineArcIntersection(p1.from, p1.to, p2.from, p2.to, ringCenter.cx, ringCenter.cy, p2.radius);
              if (int) crossingAngle = 50;
            } else if (p1.type === 'arc' && p2.type === 'line') {
              int = lineArcIntersection(p2.from, p2.to, p1.from, p1.to, ringCenter.cx, ringCenter.cy, p1.radius);
              if (int) crossingAngle = 50;
            }

            if (int) {
              allIntersections.push({ ...int, pathIndices: [i, j], crossingAngle, useCircle: crossingAngle < 45, ringIdx });
            }
          }
        }

        // Generate SVG paths for this ring
        for (const p of pathData) {
          if (p.type === 'line') {
            allPaths.push({ type: 'line', d: `M ${p.from.x} ${p.from.y} L ${p.to.x} ${p.to.y}` });
          } else {
            allPaths.push({ type: 'arc', d: arcPathD(p.from, p.to, ringCenter.cx, ringCenter.cy, p.radius), arcData: p });
          }
        }

        // Generate arc dots for this ring
        for (let i = 0; i < pathData.length; i++) {
          const p = pathData[i];
          if (p.type !== 'arc') continue;

          const arcLength = getArcLength(p.from, p.to, ringCenter.cx, ringCenter.cy, p.radius);
          const circumference = 2 * Math.PI * p.radius;

          let numDots = 0;
          if (arcLength >= circumference / 2) numDots = 3;
          else if (arcLength >= circumference / 3) numDots = 2;
          else if (arcLength >= circumference / 4) numDots = 1;
          numDots = Math.min(numDots, 3);

          if (numDots > 0) {
            const arcSeed = p.from.number * 100 + p.to.number + i * 7 + ringIdx * 1000;
            const dotsForThisArc = [];

            for (let d = 0; d < numDots; d++) {
              const baseT = (d + 0.5) / numDots;
              const jitter = (seededRandom(arcSeed + d * 73) - 0.5) * 0.15;
              const t = Math.max(0.1, Math.min(0.9, baseT + jitter));
              const pt = getArcPoint(p.from, p.to, ringCenter.cx, ringCenter.cy, p.radius, t);
              const overlaps = dotsForThisArc.some(existing => Math.hypot(existing.x - pt.x, existing.y - pt.y) < 8);
              if (!overlaps) dotsForThisArc.push(pt);
            }
            allArcDots.push(...dotsForThisArc);
          }
        }

        // Generate markers for this ring
        const startPoint = sortedRingPoints[0];
        const endPoint = sortedRingPoints[sortedRingPoints.length - 1];
        const connectEnd = ringCenter.connectEnd; // 'start' or 'end' - which point is on prev ring's line

        // Get the last path segment to calculate proper incoming angle (handles arcs correctly)
        const lastPath = pathData.length > 0 ? pathData[pathData.length - 1] : null;

        if (ringIdx === 0) {
          // Ring 1: standard start marker (hollow circle + dot) and bar end marker
          markers.push({ type: 'start', ...startPoint, ringIdx: 0 });

          const secondLastPoint = sortedRingPoints.length > 1 ? sortedRingPoints[sortedRingPoints.length - 2] : startPoint;
          const incomingAngle = getIncomingAngle(lastPath, endPoint, secondLastPoint);
          markers.push({
            type: 'end',
            ...endPoint,
            incomingAngle,
            barLen: 8,
            endStyle: 'bar',
            ringIdx
          });
        } else {
          // Ring 2+: one end is the junction (no marker there), other end gets a marker
          // End markers alternate: Ring 1 = circle, Ring 2 = bar, etc.
          const endStyle = ringIdx % 2 === 1 ? 'circle' : 'bar';

          if (connectEnd === 'start') {
            // Start point is junction - no start marker, only end marker
            const secondLastPoint = sortedRingPoints.length > 1 ? sortedRingPoints[sortedRingPoints.length - 2] : startPoint;
            const incomingAngle = getIncomingAngle(lastPath, endPoint, secondLastPoint);
            markers.push({
              type: 'end',
              ...endPoint,
              incomingAngle,
              barLen: 8,
              endStyle,
              ringIdx
            });
          } else {
            // End point is junction - has start marker, no end marker
            markers.push({ type: 'start', ...startPoint, ringIdx });
          }
        }
      }

      // Consolidate intersections
      const consolidateRadius = 12;
      const consolidatedIntersections = [];
      const used = new Set();

      for (let i = 0; i < allIntersections.length; i++) {
        if (used.has(i)) continue;
        let sumX = allIntersections[i].x, sumY = allIntersections[i].y;
        let count = 1;
        let angles = [allIntersections[i].crossingAngle];

        for (let j = i + 1; j < allIntersections.length; j++) {
          if (used.has(j)) continue;
          const dist = Math.hypot(allIntersections[i].x - allIntersections[j].x, allIntersections[i].y - allIntersections[j].y);
          if (dist < consolidateRadius) {
            sumX += allIntersections[j].x;
            sumY += allIntersections[j].y;
            count++;
            angles.push(allIntersections[j].crossingAngle);
            used.add(j);
          }
        }
        used.add(i);

        const avgAngle = angles.reduce((a, b) => a + b, 0) / angles.length;
        const useCircle = count >= 2 || avgAngle < 45;

        consolidatedIntersections.push({
          x: sumX / count, y: sumY / count,
          crossingAngle: avgAngle,
          useCircle, consolidated: count
        });
      }

      const circleIntersections = consolidatedIntersections.filter(int => int.useCircle);

      return {
        paths: allPaths,
        markers,
        intersections: circleIntersections,
        allIntersections: consolidatedIntersections,
        acuteVertices: allAcuteVertices,
        arcDots: allArcDots,
        cx, cy,
        rings,
        maxRadius,
        layoutMode: 'chained',
        layout,
        points,
        size,
        junctionDots: showJunctionDots ? junctionDots : [],
        ringCenters,
        contentBounds: layout.contentBounds
      };
    };

    // Generate sigil from a pre-computed layout
    const generateSigilFromLayout = (unique, numbers, size, pointsPerRing, layout, layoutMode, cx, cy) => {
      const { points, rings, maxRadius } = layout;
      const n = unique.length;

      if (n < 2) return { paths: [], markers: [], intersections: [], acuteVertices: [], arcDots: [], cx, cy, rings: [], maxRadius: 0, layoutMode, layout, points: [], size };

      const sortedByValue = [...points].sort((a, b) => a.number - b.number);

      const allAcuteVertices = [];
      for (let i = 1; i < sortedByValue.length - 1; i++) {
        const prev = sortedByValue[i - 1];
        const curr = sortedByValue[i];
        const next = sortedByValue[i + 1];
        const vertexAngle = calculateVertexAngle(prev, curr, next);
        if (vertexAngle < 30 || vertexAngle > 150) {
          allAcuteVertices.push({ x: curr.x, y: curr.y, angle: vertexAngle, index: i });
        }
      }

      const seed = unique.reduce((s, c) => s + c.charCodeAt(0), 0);
      const acuteVertices = allAcuteVertices.filter((_, idx) => seededRandom(seed + idx * 17) > 0.5);

      const pathData = [];
      for (let i = 0; i < sortedByValue.length - 1; i++) {
        const from = sortedByValue[i];
        const to = sortedByValue[i + 1];
        const adjacent = isAdjacentOnRing(from, to, pointsPerRing);
        pathData.push({
          type: adjacent ? 'arc' : 'line',
          from, to,
          radius: adjacent ? from.radius : null,
          index: i
        });
      }

      const allIntersections = [];
      for (let i = 0; i < pathData.length; i++) {
        for (let j = i + 1; j < pathData.length; j++) {
          const p1 = pathData[i];
          const p2 = pathData[j];
          let int = null;
          let crossingAngle = 45;

          if (p1.type === 'line' && p2.type === 'line') {
            int = lineLineIntersection(p1.from, p1.to, p2.from, p2.to);
            if (int) crossingAngle = calculateCrossingAngle(p1.from, p1.to, p2.from, p2.to);
          } else if (p1.type === 'line' && p2.type === 'arc') {
            const arcCx = p2.from.circleCx ?? cx;
            const arcCy = p2.from.circleCy ?? cy;
            int = lineArcIntersection(p1.from, p1.to, p2.from, p2.to, arcCx, arcCy, p2.radius);
            if (int) crossingAngle = 50;
          } else if (p1.type === 'arc' && p2.type === 'line') {
            const arcCx = p1.from.circleCx ?? cx;
            const arcCy = p1.from.circleCy ?? cy;
            int = lineArcIntersection(p2.from, p2.to, p1.from, p1.to, arcCx, arcCy, p1.radius);
            if (int) crossingAngle = 50;
          }

          if (int) {
            allIntersections.push({ ...int, pathIndices: [i, j], crossingAngle });
          }
        }
      }

      const consolidateRadius = 12;
      const intersections = [];
      const used = new Set();

      for (let i = 0; i < allIntersections.length; i++) {
        if (used.has(i)) continue;
        let sumX = allIntersections[i].x, sumY = allIntersections[i].y;
        const pathSet = new Set(allIntersections[i].pathIndices);
        let angles = [allIntersections[i].crossingAngle];
        let count = 1;

        for (let j = i + 1; j < allIntersections.length; j++) {
          if (used.has(j)) continue;
          const dist = Math.hypot(allIntersections[i].x - allIntersections[j].x, allIntersections[i].y - allIntersections[j].y);
          if (dist < consolidateRadius) {
            sumX += allIntersections[j].x;
            sumY += allIntersections[j].y;
            count++;
            allIntersections[j].pathIndices.forEach(p => pathSet.add(p));
            angles.push(allIntersections[j].crossingAngle);
            used.add(j);
          }
        }
        used.add(i);

        const avgAngle = angles.reduce((a, b) => a + b, 0) / angles.length;
        const forceCircle = count >= 2;
        const useCircle = forceCircle || avgAngle < 45;

        intersections.push({
          x: sumX / count, y: sumY / count,
          pathIndices: [...pathSet], crossingAngle: avgAngle,
          useCircle, consolidated: count
        });
      }

      const paths = [];
      const breakGap = 17;

      for (let pathIdx = 0; pathIdx < pathData.length; pathIdx++) {
        const p = pathData[pathIdx];
        const lineBreakIntersections = intersections.filter(int => !int.useCircle && int.pathIndices.includes(pathIdx));
        const myBreaks = lineBreakIntersections.filter(int => {
          const globalIdx = intersections.indexOf(int);
          const amIFirst = int.pathIndices[0] === pathIdx;
          return amIFirst ? (globalIdx % 2 === 0) : (globalIdx % 2 === 1);
        });

        if (p.type === 'line') {
          const from = p.from, to = p.to;
          const dx = to.x - from.x, dy = to.y - from.y;
          const len = Math.hypot(dx, dy);
          if (len === 0) continue;
          const ux = dx / len, uy = dy / len;

          if (myBreaks.length === 0) {
            paths.push({ type: 'line', d: `M ${from.x} ${from.y} L ${to.x} ${to.y}` });
          } else {
            const breaksWithDist = myBreaks.map(b => ({ ...b, dist: Math.hypot(b.x - from.x, b.y - from.y) })).sort((a, b) => a.dist - b.dist);
            let currentX = from.x, currentY = from.y;
            for (const brk of breaksWithDist) {
              const gapStartX = brk.x - ux * (breakGap / 2);
              const gapStartY = brk.y - uy * (breakGap / 2);
              const segLen = Math.hypot(gapStartX - currentX, gapStartY - currentY);
              if (segLen > 3) paths.push({ type: 'line', d: `M ${currentX} ${currentY} L ${gapStartX} ${gapStartY}` });
              currentX = brk.x + ux * (breakGap / 2);
              currentY = brk.y + uy * (breakGap / 2);
            }
            const finalLen = Math.hypot(to.x - currentX, to.y - currentY);
            if (finalLen > 3) paths.push({ type: 'line', d: `M ${currentX} ${currentY} L ${to.x} ${to.y}` });
          }
        } else {
          const arcCx = p.from.circleCx ?? cx;
          const arcCy = p.from.circleCy ?? cy;
          paths.push({ type: 'arc', d: arcPathD(p.from, p.to, arcCx, arcCy, p.radius), arcData: p });
        }
      }

      const arcDots = [];
      for (let i = 0; i < pathData.length; i++) {
        const p = pathData[i];
        if (p.type !== 'arc') continue;
        const arcCx = p.from.circleCx ?? cx;
        const arcCy = p.from.circleCy ?? cy;
        const arcLength = getArcLength(p.from, p.to, arcCx, arcCy, p.radius);
        const circumference = 2 * Math.PI * p.radius;
        let numDots = 0;
        if (arcLength >= circumference / 2) numDots = 3;
        else if (arcLength >= circumference / 3) numDots = 2;
        else if (arcLength >= circumference / 4) numDots = 1;
        numDots = Math.min(numDots, 3);

        if (numDots > 0) {
          const arcSeed = p.from.number * 100 + p.to.number + i * 7;
          const dotsForThisArc = [];
          for (let d = 0; d < numDots; d++) {
            const baseT = (d + 0.5) / numDots;
            const jitter = (seededRandom(arcSeed + d * 73) - 0.5) * 0.15;
            const t = Math.max(0.1, Math.min(0.9, baseT + jitter));
            const pt = getArcPoint(p.from, p.to, arcCx, arcCy, p.radius, t);
            const overlaps = dotsForThisArc.some(existing => Math.hypot(existing.x - pt.x, existing.y - pt.y) < 8);
            if (!overlaps) dotsForThisArc.push(pt);
          }
          arcDots.push(...dotsForThisArc);
        }
      }

      const lastPoint = sortedByValue[sortedByValue.length - 1];
      const secondLastPoint = sortedByValue[sortedByValue.length - 2];
      const lastPathIndex = pathData.length - 1;
      const lastPath = pathData[lastPathIndex];
      const incomingAngle = getIncomingAngle(lastPath, lastPoint, secondLastPoint);
      const perpAngle = incomingAngle + Math.PI / 2;

      let bestLen = 8, bestClearance = 0;
      for (let testLen = 3; testLen <= 20; testLen++) {
        const clearance = getBarCollisionDistance(lastPoint, perpAngle, testLen, pathData, cx, cy, lastPathIndex);
        if (clearance > testLen + 2) {
          if (testLen >= 6 && testLen <= 10) { bestLen = testLen; bestClearance = clearance; break; }
          else if (clearance > bestClearance) { bestLen = testLen; bestClearance = clearance; }
        }
      }

      const markers = [
        { type: 'start', ...sortedByValue[0] },
        { type: 'end', ...sortedByValue[sortedByValue.length - 1], incomingAngle, barLen: bestLen }
      ];

      const circleIntersections = intersections.filter(int => int.useCircle);

      return {
        paths, markers, intersections: circleIntersections, allIntersections: intersections,
        acuteVertices, arcDots, cx, cy, rings, maxRadius, layoutMode, layout, points, size
      };
    };

    const generateSigil = (unique, numbers, size = 200, pointsPerRing = 6, layoutMode = LayoutMode.STANDARD) => {
      const cx = size / 2;
      const cy = size / 2;
      const n = unique.length;

      if (n < 2) return { paths: [], markers: [], intersections: [], acuteVertices: [], arcDots: [], cx, cy, rings: [], maxRadius: 0, layoutMode };

      const layout = generatePoints(unique, numbers, size, pointsPerRing, layoutMode, cx, cy);
      const { points, rings, maxRadius } = layout;

      const sortedByValue = [...points].sort((a, b) => a.number - b.number);

      const allAcuteVertices = [];
      for (let i = 1; i < sortedByValue.length - 1; i++) {
        const prev = sortedByValue[i - 1];
        const curr = sortedByValue[i];
        const next = sortedByValue[i + 1];

        const vertexAngle = calculateVertexAngle(prev, curr, next);
        if (vertexAngle < 30 || vertexAngle > 150) {
          allAcuteVertices.push({ x: curr.x, y: curr.y, angle: vertexAngle, index: i });
        }
      }

      const seed = unique.reduce((s, c) => s + c.charCodeAt(0), 0);
      const acuteVertices = allAcuteVertices.filter((_, idx) => seededRandom(seed + idx * 17) > 0.5);

      const pathData = [];
      for (let i = 0; i < sortedByValue.length - 1; i++) {
        const from = sortedByValue[i];
        const to = sortedByValue[i + 1];
        const adjacent = isAdjacentOnRing(from, to, pointsPerRing);

        pathData.push({
          type: adjacent ? 'arc' : 'line',
          from, to,
          radius: adjacent ? from.radius : null,
          index: i
        });
      }

      const allIntersections = [];

      for (let i = 0; i < pathData.length; i++) {
        for (let j = i + 1; j < pathData.length; j++) {
          const p1 = pathData[i];
          const p2 = pathData[j];

          let int = null;
          let crossingAngle = 45;

          if (p1.type === 'line' && p2.type === 'line') {
            int = lineLineIntersection(p1.from, p1.to, p2.from, p2.to);
            if (int) {
              crossingAngle = calculateCrossingAngle(p1.from, p1.to, p2.from, p2.to);
            }
          } else if (p1.type === 'line' && p2.type === 'arc') {
            const arcCx = p2.from.circleCx ?? cx;
            const arcCy = p2.from.circleCy ?? cy;
            int = lineArcIntersection(p1.from, p1.to, p2.from, p2.to, arcCx, arcCy, p2.radius);
            if (int) crossingAngle = 50;
          } else if (p1.type === 'arc' && p2.type === 'line') {
            const arcCx = p1.from.circleCx ?? cx;
            const arcCy = p1.from.circleCy ?? cy;
            int = lineArcIntersection(p2.from, p2.to, p1.from, p1.to, arcCx, arcCy, p1.radius);
            if (int) crossingAngle = 50;
          }

          if (int) {
            allIntersections.push({
              ...int,
              pathIndices: [i, j],
              crossingAngle
            });
          }
        }
      }

      const consolidateRadius = 12;
      const intersections = [];
      const used = new Set();

      for (let i = 0; i < allIntersections.length; i++) {
        if (used.has(i)) continue;

        let sumX = allIntersections[i].x, sumY = allIntersections[i].y;
        const pathSet = new Set(allIntersections[i].pathIndices);
        let angles = [allIntersections[i].crossingAngle];
        let count = 1;

        for (let j = i + 1; j < allIntersections.length; j++) {
          if (used.has(j)) continue;
          const dist = Math.hypot(allIntersections[i].x - allIntersections[j].x, allIntersections[i].y - allIntersections[j].y);
          if (dist < consolidateRadius) {
            sumX += allIntersections[j].x;
            sumY += allIntersections[j].y;
            count++;
            allIntersections[j].pathIndices.forEach(p => pathSet.add(p));
            angles.push(allIntersections[j].crossingAngle);
            used.add(j);
          }
        }
        used.add(i);

        const avgAngle = angles.reduce((a, b) => a + b, 0) / angles.length;
        const forceCircle = count >= 2;
        const useCircle = forceCircle || avgAngle < 45;

        intersections.push({
          x: sumX / count,
          y: sumY / count,
          pathIndices: [...pathSet],
          crossingAngle: avgAngle,
          useCircle,
          consolidated: count
        });
      }

      const paths = [];
      const breakGap = 17;

      for (let pathIdx = 0; pathIdx < pathData.length; pathIdx++) {
        const p = pathData[pathIdx];

        const lineBreakIntersections = intersections.filter(int =>
          !int.useCircle && int.pathIndices.includes(pathIdx)
        );

        const myBreaks = lineBreakIntersections.filter(int => {
          const globalIdx = intersections.indexOf(int);
          const amIFirst = int.pathIndices[0] === pathIdx;
          return amIFirst ? (globalIdx % 2 === 0) : (globalIdx % 2 === 1);
        });

        if (p.type === 'line') {
          const from = p.from;
          const to = p.to;
          const dx = to.x - from.x;
          const dy = to.y - from.y;
          const len = Math.hypot(dx, dy);

          if (len === 0) continue;

          const ux = dx / len, uy = dy / len;

          if (myBreaks.length === 0) {
            paths.push({ type: 'line', d: `M ${from.x} ${from.y} L ${to.x} ${to.y}` });
          } else {
            const breaksWithDist = myBreaks.map(b => ({
              ...b,
              dist: Math.hypot(b.x - from.x, b.y - from.y)
            })).sort((a, b) => a.dist - b.dist);

            let currentX = from.x, currentY = from.y;

            for (const brk of breaksWithDist) {
              const gapStartX = brk.x - ux * (breakGap / 2);
              const gapStartY = brk.y - uy * (breakGap / 2);

              const segLen = Math.hypot(gapStartX - currentX, gapStartY - currentY);
              if (segLen > 3) {
                paths.push({ type: 'line', d: `M ${currentX} ${currentY} L ${gapStartX} ${gapStartY}` });
              }

              currentX = brk.x + ux * (breakGap / 2);
              currentY = brk.y + uy * (breakGap / 2);
            }

            const finalLen = Math.hypot(to.x - currentX, to.y - currentY);
            if (finalLen > 3) {
              paths.push({ type: 'line', d: `M ${currentX} ${currentY} L ${to.x} ${to.y}` });
            }
          }
        } else {
          const arcCx = p.from.circleCx ?? cx;
          const arcCy = p.from.circleCy ?? cy;
          paths.push({ type: 'arc', d: arcPathD(p.from, p.to, arcCx, arcCy, p.radius), arcData: p });
        }
      }

      const arcDots = [];

      for (let i = 0; i < pathData.length; i++) {
        const p = pathData[i];
        if (p.type !== 'arc') continue;

        const arcCx = p.from.circleCx ?? cx;
        const arcCy = p.from.circleCy ?? cy;
        const arcLength = getArcLength(p.from, p.to, arcCx, arcCy, p.radius);
        const circumference = 2 * Math.PI * p.radius;

        let numDots = 0;
        if (arcLength >= circumference / 2) numDots = 3;
        else if (arcLength >= circumference / 3) numDots = 2;
        else if (arcLength >= circumference / 4) numDots = 1;

        numDots = Math.min(numDots, 3);

        if (numDots > 0) {
          const arcSeed = p.from.number * 100 + p.to.number + i * 7;
          const dotsForThisArc = [];

          for (let d = 0; d < numDots; d++) {
            const baseT = (d + 0.5) / numDots;
            const jitter = (seededRandom(arcSeed + d * 73) - 0.5) * 0.15;
            const t = Math.max(0.1, Math.min(0.9, baseT + jitter));

            const pt = getArcPoint(p.from, p.to, arcCx, arcCy, p.radius, t);

            const overlaps = dotsForThisArc.some(existing =>
              Math.hypot(existing.x - pt.x, existing.y - pt.y) < 8
            );

            if (!overlaps) {
              dotsForThisArc.push(pt);
            }
          }

          arcDots.push(...dotsForThisArc);
        }
      }

      const lastPoint = sortedByValue[sortedByValue.length - 1];
      const secondLastPoint = sortedByValue[sortedByValue.length - 2];
      const lastPathIndex = pathData.length - 1;
      const lastPath = pathData[lastPathIndex];
      const incomingAngle = getIncomingAngle(lastPath, lastPoint, secondLastPoint);
      const perpAngle = incomingAngle + Math.PI / 2;

      let bestLen = 8;
      let bestClearance = 0;

      for (let testLen = 3; testLen <= 20; testLen++) {
        const clearance = getBarCollisionDistance(lastPoint, perpAngle, testLen, pathData, cx, cy, lastPathIndex);
        if (clearance > testLen + 2) {
          if (testLen >= 6 && testLen <= 10) {
            bestLen = testLen;
            bestClearance = clearance;
            break;
          } else if (clearance > bestClearance) {
            bestLen = testLen;
            bestClearance = clearance;
          }
        }
      }

      const markers = [
        { type: 'start', ...sortedByValue[0] },
        { type: 'end', ...sortedByValue[sortedByValue.length - 1], incomingAngle, barLen: bestLen }
      ];

      const circleIntersections = intersections.filter(int => int.useCircle);

      return {
        paths, markers, intersections: circleIntersections, allIntersections: intersections,
        acuteVertices, arcDots, cx, cy, rings, maxRadius, layoutMode, layout, points, size
      };
    };

    // Generate sigil with alternatives when hot zones detected (or always if forceAll is true)
    const generateSigilWithAlternatives = (unique, numbers, size = 200, pointsPerRing = 6, forceAll = false) => {
      const standard = generateSigil(unique, numbers, size, pointsPerRing, LayoutMode.STANDARD);
      const heat = analyzeHeatMap(standard.allIntersections, size);

      if (!heat.isHot && !forceAll) {
        return {
          layouts: { standard },
          isHot: false,
          heatAnalysis: heat,
          recommendedLayout: 'standard'
        };
      }

      const venn = generateSigil(unique, numbers, size, pointsPerRing, LayoutMode.VENN);
      const extraRings = generateSigil(unique, numbers, size, pointsPerRing, LayoutMode.EXTRA_RINGS);
      const satellite = generateSigil(unique, numbers, size, pointsPerRing, LayoutMode.SATELLITE);

      const layouts = { standard, venn, extra_rings: extraRings, satellite };
      const scores = {};

      for (const [name, sigil] of Object.entries(layouts)) {
        const heatResult = analyzeHeatMap(sigil.allIntersections, size);
        scores[name] = heatResult.globalScore;
      }

      const recommendedLayout = Object.entries(scores)
        .sort((a, b) => a[1] - b[1])[0][0];

      return {
        layouts,
        scores,
        isHot: heat.isHot,
        heatAnalysis: heat,
        recommendedLayout
      };
    };

    const SigilSVG = ({ sigil, size, showGuides = false, showHeatMap = false, showDots = true, showLabels = false, heatAnalysis = null, generatedSize = null, svgId = null, darkMode = false, showCenterDot = true, markerScale = 1, thinStroke = false, printMode = false, pathStrokeMult = 1 }) => {
      // Safety check - if sigil is missing required data, render empty
      if (!sigil || !sigil.paths) {
        return <svg id={svgId} width={size} height={size} style={{background: '#fafaf9', borderRadius: getSize(SIZE_RATIOS.radiusMd)}} />;
      }

      const color = darkMode ? "#ffffff" : "#3f3f46";
      const bgColor = darkMode ? "#1a1a1a" : "#fafaf9";
      // Stroke width multiplier - thicker for print, reduced for thin stroke mode
      const strokeMult = printMode ? 3.0 : (thinStroke ? 0.5 : 1);
      // Additional multiplier for path strokes only (main sigil can be thicker)
      const effectivePathStrokeMult = strokeMult * pathStrokeMult;
      // Marker scale for print mode - slightly larger terminals and dots
      const effectiveMarkerScale = printMode ? markerScale * 1.3 : markerScale;

      // For chained layouts, use tight contentBounds viewBox to reduce whitespace
      const isChained = sigil.layoutMode === 'chained' || sigil.layoutMode === LayoutMode.CHAINED;
      const contentBounds = sigil.contentBounds;

      let viewBox;
      let strokeScale;

      if (isChained && contentBounds) {
        // Use content bounds for chained layouts - zoom to fit content
        viewBox = `${contentBounds.x} ${contentBounds.y} ${contentBounds.width} ${contentBounds.height}`;
        // Scale strokes based on the larger dimension of content bounds
        const maxDim = Math.max(contentBounds.width, contentBounds.height);
        strokeScale = maxDim / size;
      } else {
        // Standard viewBox for other layouts
        const viewBoxSize = generatedSize || size;
        viewBox = `0 0 ${viewBoxSize} ${viewBoxSize}`;
        strokeScale = viewBoxSize / size;
      }

      const renderGuides = () => {
        const guides = [];
        const layout = sigil.layout;
        // Consistent guide style: soft sage green, 1.5px stroke, 4,4 dash
        const guideColor = "#9cb99c";
        const guideStroke = 1.5 * strokeScale;
        const guideDash = "4,4";

        if ((sigil.layoutMode === LayoutMode.VENN || sigil.layoutMode === 'venn') && layout) {
          if (layout.centers) {
            // 3-circle Venn
            layout.centers.forEach((center, i) => {
              guides.push(
                <circle key={`venn-${i}`} cx={center.x} cy={center.y} r={sigil.maxRadius}
                  fill="none" stroke={guideColor} strokeWidth={guideStroke} strokeDasharray={guideDash} />
              );
            });
          } else {
            // 2-circle Venn
            guides.push(
              <circle key="venn-left" cx={layout.leftCx} cy={layout.cy} r={sigil.maxRadius}
                fill="none" stroke={guideColor} strokeWidth={guideStroke} strokeDasharray={guideDash} />
            );
            guides.push(
              <circle key="venn-right" cx={layout.rightCx} cy={layout.cy} r={sigil.maxRadius}
                fill="none" stroke={guideColor} strokeWidth={guideStroke} strokeDasharray={guideDash} />
            );
          }
        } else if ((sigil.layoutMode === LayoutMode.SATELLITE || sigil.layoutMode === 'satellite') && layout) {
          guides.push(
            <circle key="sat-main" cx={layout.mainCx} cy={layout.satCy} r={layout.mainRadius}
              fill="none" stroke={guideColor} strokeWidth={guideStroke} strokeDasharray={guideDash} />
          );
          if (layout.hasConnector) {
            guides.push(
              <circle key="sat-satellite" cx={layout.satCx} cy={layout.satCy} r={layout.satRadius}
                fill="none" stroke={guideColor} strokeWidth={guideStroke} strokeDasharray={guideDash} />
            );
          }
        } else if ((sigil.layoutMode === LayoutMode.CHAINED || sigil.layoutMode === 'chained') && sigil.ringCenters) {
          // Chained layout: show each ring's guide circle
          sigil.ringCenters.forEach((ring, i) => {
            guides.push(
              <circle key={`chained-ring-${i}`} cx={ring.cx} cy={ring.cy} r={ring.radius}
                fill="none" stroke={guideColor} strokeWidth={guideStroke} strokeDasharray={guideDash} />
            );
          });
        } else if (sigil.rings) {
          // Standard layout
          sigil.rings.forEach((r, i) => {
            guides.push(
              <circle key={`ring-${i}`} cx={sigil.cx} cy={sigil.cy} r={r}
                fill="none" stroke={guideColor} strokeWidth={guideStroke} strokeDasharray={guideDash} />
            );
          });
        }
        return guides;
      };

      return (
        <svg id={svgId} width={size} height={size} viewBox={viewBox} overflow="visible" style={{background: '#fafaf9', borderRadius: getSize(SIZE_RATIOS.radiusMd), overflow: 'visible'}}>
          {showHeatMap && heatAnalysis && (
            <g>
              {heatAnalysis.cells.filter(c => c.count > 0).map((cell, i) => (
                <rect key={`heat-cell-${i}`}
                  x={cell.x} y={cell.y}
                  width={heatAnalysis.cellSize} height={heatAnalysis.cellSize}
                  fill={darkMode ? "#ff6b6b" : "red"}
                  opacity={darkMode ? Math.min(0.7, cell.count * 0.25) : Math.min(0.4, cell.count * 0.15)}
                />
              ))}
              {heatAnalysis.zones.map((zone, i) => (
                <circle key={`heat-zone-${i}`}
                  cx={zone.centerX} cy={zone.centerY} r={zone.radius}
                  fill="none" stroke={darkMode ? "#ff6b6b" : "red"} strokeWidth="2" strokeDasharray="4,4"
                  opacity={darkMode ? 0.9 : 0.7}
                />
              ))}
            </g>
          )}

          {showGuides && renderGuides()}

          {showCenterDot && <circle cx={sigil.cx} cy={sigil.cy} r={2} fill={color} opacity={0.15} />}

          {(sigil.paths || []).map((p, i) => (
            <path key={i} d={p.d} fill="none" stroke={color} strokeWidth={2 * strokeScale * effectivePathStrokeMult} strokeLinecap="round" />
          ))}

          {(sigil.intersections || []).map((int, i) => (
            <circle key={`int-${i}`} cx={int.x} cy={int.y} r={4 * strokeScale * effectiveMarkerScale} fill={bgColor} stroke={color} strokeWidth={1.5 * strokeScale * effectiveMarkerScale * strokeMult} />
          ))}

          {/* Acute vertex dots - always shown (structural, mark sharp angles) */}
          {(sigil.acuteVertices || []).map((v, i) => (
            <circle key={`acute-${i}`} cx={v.x} cy={v.y} r={3 * strokeScale * effectiveMarkerScale} fill={color} />
          ))}

          {/* Arc decorative dots - controlled by showDots toggle */}
          {showDots && (sigil.arcDots || []).map((d, i) => (
            <circle key={`arcdot-${i}`} cx={d.x} cy={d.y} r={2 * strokeScale * effectiveMarkerScale} fill={color} />
          ))}

          {(sigil.markers || []).filter(m => m.type === 'start').map((m, i) => (
            <g key={`start-${i}`}>
              <circle cx={m.x} cy={m.y} r={6 * strokeScale * effectiveMarkerScale} fill={bgColor} stroke={color} strokeWidth={2 * strokeScale * effectiveMarkerScale * strokeMult} />
              <circle cx={m.x} cy={m.y} r={2 * strokeScale * effectiveMarkerScale} fill={color} />
            </g>
          ))}

          {(sigil.markers || []).filter(m => m.type === 'end').map((m, i) => {
            const perpAngle = m.incomingAngle + Math.PI / 2;
            // For chained layouts, use endStyle to determine bar vs circle
            // Default to bar for non-chained layouts
            const endStyle = m.endStyle || 'bar';
            const barLen = (m.barLen || 8) * strokeScale * effectiveMarkerScale;

            if (endStyle === 'circle') {
              // Circle end marker (hollow circle, no dot)
              return (
                <circle
                  key={`end-${i}`}
                  cx={m.x}
                  cy={m.y}
                  r={5 * strokeScale * effectiveMarkerScale}
                  fill={bgColor}
                  stroke={color}
                  strokeWidth={2 * strokeScale * effectiveMarkerScale * strokeMult}
                />
              );
            }
            // Bar end marker (default)
            return (
              <line
                key={`end-${i}`}
                x1={m.x + Math.cos(perpAngle) * barLen}
                y1={m.y + Math.sin(perpAngle) * barLen}
                x2={m.x - Math.cos(perpAngle) * barLen}
                y2={m.y - Math.sin(perpAngle) * barLen}
                stroke={color}
                strokeWidth={3 * strokeScale * effectiveMarkerScale * strokeMult}
                strokeLinecap="round"
              />
            );
          })}


          {/* Junction dots for chained layouts */}
          {sigil.junctionDots && sigil.junctionDots.map((dot, i) => (
            <circle
              key={`junction-${i}`}
              cx={dot.x}
              cy={dot.y}
              r={3 * strokeScale * effectiveMarkerScale}
              fill={color}
            />
          ))}

          {showLabels && sigil.points && sigil.points.map((p, i) => (
            <g key={`label-${i}`}>
              <text
                x={p.x}
                y={p.y - 8 * strokeScale}
                textAnchor="middle"
                fontSize={10 * strokeScale}
                fill={color}
                fontFamily="monospace"
                fontWeight="500"
              >
                {p.letter}
              </text>
              <text
                x={p.x}
                y={p.y + 14 * strokeScale}
                textAnchor="middle"
                fontSize={9 * strokeScale}
                fill="#a1a1aa"
                fontFamily="monospace"
              >
                {p.number}
              </text>
            </g>
          ))}
        </svg>
      );
    };

    // 2x2 comparison grid for alternative layouts
    const LayoutComparisonGrid = ({ result, size, showGuides, showHeatMap }) => {
      const layoutNames = {
        standard: 'Standard',
        venn: 'Venn',
        extra_rings: 'Extra Rings',
        satellite: 'Satellite'
      };

      return (
        <div className="layout-grid">
          {Object.entries(result.layouts).map(([name, sigil]) => (
            <div key={name} className="layout-cell">
              <SigilSVG
                sigil={sigil}
                size={size}
                generatedSize={sigil.size}
                showGuides={showGuides}
                showHeatMap={showHeatMap}
                heatAnalysis={analyzeHeatMap(sigil.allIntersections, sigil.size)}
              />
              <span className={`layout-label ${name === result.recommendedLayout ? 'recommended' : ''}`}>
                {layoutNames[name]} ({result.scores?.[name] ?? 0})
                {name === result.recommendedLayout && ' *'}
              </span>
            </div>
          ))}
        </div>
      );
    };

    // Error boundary to catch React errors and prevent blank page
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }
      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }
      componentDidCatch(error, errorInfo) {
        console.error('React Error:', error, errorInfo);
      }
      render() {
        if (this.state.hasError) {
          return (
            <div style={{padding: getSize(SIZE_RATIOS.spMd), color: '#dc2626', background: '#fef2f2', margin: getSize(SIZE_RATIOS.spMd), borderRadius: getSize(SIZE_RATIOS.radiusMd)}}>
              <h2>Something went wrong</h2>
              <pre style={{fontSize: getSize(SIZE_RATIOS.fontSecondary), overflow: 'auto'}}>{this.state.error?.toString()}</pre>
              <button onClick={() => this.setState({ hasError: false, error: null })} style={{marginTop: getSize(SIZE_RATIOS.sp2xs), padding: `${getSize(SIZE_RATIOS.sp3xs)}px ${getSize(SIZE_RATIOS.spSm)}px`}}>
                Try Again
              </button>
            </div>
          );
        }
        return this.props.children;
      }
    }

    function App() {
      const [customText, setCustomText] = useState('edit your sigil text to start');
      const [activeTab, setActiveTab] = useState(0); // 0 = custom, 1+ = examples

      // Dark mode
      const [darkMode, setDarkMode] = useState(false);

      // Selected sigil for detail panel
      const [selectedSigil, setSelectedSigil] = useState(null);

      // Showcase panel state - start collapsed on mobile
      const isMobile = window.innerWidth <= 768;
      const [showcaseExpanded, setShowcaseExpanded] = useState(!isMobile);
      const [showcaseDarkMode, setShowcaseDarkMode] = useState(false);
      const [printPreview, setPrintPreview] = useState(false);

      // Display toggles
      const [showGuides, setShowGuides] = useState(true);
      const [showHeatMap, setShowHeatMap] = useState(false);
      const [showDots, setShowDots] = useState(false);
      const [showLabels, setShowLabels] = useState(false);
      const [heatFilter, setHeatFilter] = useState('all'); // 'all', 'perfect', 'no-hot'

      // Collapsible sections
      const [standardExpanded, setStandardExpanded] = useState(true);
      const [vennExpanded, setVennExpanded] = useState(true);
      const [satelliteExpanded, setSatelliteExpanded] = useState(true);
      const [chainedExpanded, setChainedExpanded] = useState(true);
      const [examplesExpanded, setExamplesExpanded] = useState(false);

      // Standard layout options - all selected by default
      const [standardEnabled, setStandardEnabled] = useState(true);
      const [standardPointsPerRing, setStandardPointsPerRing] = useState([3, 4, 5, 6, 7, 8, 9, 10]);
      const [standardRingCounts, setStandardRingCounts] = useState([1, 2, 3, 4, 5]);

      // Venn layout options - all selected by default
      const [vennEnabled, setVennEnabled] = useState(true);
      const [vennPointsPerRing, setVennPointsPerRing] = useState([3, 4, 5, 6, 7, 8, 9, 10]);
      const [vennCircleCounts, setVennCircleCounts] = useState([2, 3]);

      // Satellite layout options - all selected by default
      const [satelliteEnabled, setSatelliteEnabled] = useState(true);
      const [satellitePointsPerRing, setSatellitePointsPerRing] = useState([3, 4, 5, 6, 7, 8, 9, 10]);
      const [satelliteMainRings, setSatelliteMainRings] = useState([1, 2]);
      const [satelliteSatRings, setSatelliteSatRings] = useState([1, 2]);

      // Chained layout options
      const [chainedEnabled, setChainedEnabled] = useState(true);
      const [chainedPointsPerRing, setChainedPointsPerRing] = useState([4, 5, 6]);
      const [chainedShowJunctionDots, setChainedShowJunctionDots] = useState([true, false]);

      // Track locked rings for chained layouts (keyed by ppr)
      // Full rings get their characters AND positions locked
      // Partial rings stay flexible
      const chainedLockedRingsRef = React.useRef({});
      const prevUniqueRef = React.useRef('');

      const pointsPerRingOptions = [3, 4, 5, 6, 7, 8, 9, 10];
      const ringCountOptions = [1, 2, 3, 4, 5];
      const vennCircleOptions = [2, 3];
      const satelliteRingOptions = [1, 2];
      const chainedPointsOptions = [4, 5, 6];

      // Error/debug logging state
      const [errorLog, setErrorLog] = useState([]);
      const [errorLogExpanded, setErrorLogExpanded] = useState(false);

      // Mobile controls state
      const [mobileControlsOpen, setMobileControlsOpen] = useState(false);

      // Favorites state
      const [favorites, setFavorites] = useState([]);
      const [hiddenSigils, setHiddenSigils] = useState(new Set());

      // Generate a unique ID for a sigil item
      const getSigilId = (item) => {
        if (!item || !item.sigil) return `fallback-${Date.now()}`;
        // Include layoutType, description, and a hash of all path data for uniqueness
        const paths = item.sigil.paths || [];
        const pathStr = paths.map(p => p.d || '').join('|');
        // Simple hash function
        let hash = 0;
        for (let i = 0; i < pathStr.length; i++) {
          const char = pathStr.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        return `${item.layoutType || 'x'}-${item.description || ''}-${hash}`;
      };

      // Toggle a sigil as favorite
      const toggleFavorite = (item) => {
        try {
          if (!item || !item.sigil) return;

          const itemId = getSigilId(item);
          const exists = favorites.find(f => f.id === itemId);

          if (exists) {
            setFavorites(prev => prev.filter(f => f.id !== itemId));
          } else {
            // Create a copy with all properties needed for rendering
            const sig = item.sigil;
            // Use item.phrase if it's a favorite, otherwise get current text from example
            const phraseText = item.phrase || (activeTab === 0 ? customText : examples[activeTab - 1]?.text || '');
            const favItem = {
              id: itemId,
              phrase: phraseText,
              layoutType: item.layoutType,
              description: item.description,
              displaySize: item.displaySize,
              // Capture current toggle states at time of favoriting
              showGuides,
              showDots,
              showLabels,
              showHeatMap,
              sigil: {
                paths: sig.paths || [],
                markers: sig.markers || [],
                points: sig.points || [],
                intersections: sig.intersections || [],
                acuteVertices: sig.acuteVertices || [],
                arcDots: sig.arcDots || [],
                junctionDots: sig.junctionDots || [],
                allIntersections: sig.allIntersections || [],
                size: sig.size,
                layoutMode: sig.layoutMode,
                layout: sig.layout,
                maxRadius: sig.maxRadius,
                cx: sig.cx,
                cy: sig.cy,
                rings: sig.rings,
                ringCenters: sig.ringCenters,
                contentBounds: sig.contentBounds
              }
            };
            setFavorites(prev => [...prev, favItem]);
          }
        } catch (err) {
          console.error('Error toggling favorite:', err);
        }
      };

      // Check if a sigil is favorited
      const isFavorite = (item) => {
        if (!item || !item.sigil) return false;
        const itemId = getSigilId(item);
        return favorites.some(f => f.id === itemId);
      };

      // Toggle sigil visibility (hide/show)
      const toggleHidden = (item, e) => {
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }
        const itemId = getSigilId(item);
        setHiddenSigils(prev => {
          const newSet = new Set(prev);
          if (newSet.has(itemId)) {
            newSet.delete(itemId);
          } else {
            newSet.add(itemId);
          }
          return newSet;
        });
      };

      // Check if a sigil is hidden
      const isHidden = (item) => {
        if (!item || !item.sigil) return false;
        const itemId = getSigilId(item);
        return hiddenSigils.has(itemId);
      };

      // Export favorites as PNG
      const exportFavoriteAsPng = (favorite, index) => {
        return new Promise((resolve) => {
          const svgElement = document.getElementById(`favorite-svg-${index}`);
          if (!svgElement) {
            resolve();
            return;
          }

          const canvas = document.createElement('canvas');
          const size = getSize(SIZE_RATIOS.exportSize); // Export at higher resolution
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');

          // Clone SVG and ensure it has proper dimensions
          const clonedSvg = svgElement.cloneNode(true);
          clonedSvg.setAttribute('width', size);
          clonedSvg.setAttribute('height', size);

          // Convert SVG to image
          const svgData = new XMLSerializer().serializeToString(clonedSvg);
          const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(svgBlob);

          const img = new Image();
          img.onload = () => {
            ctx.drawImage(img, 0, 0, size, size);
            URL.revokeObjectURL(url);

            // Download
            const link = document.createElement('a');
            const safeName = (favorite.phrase || 'sigil').replace(/[^a-zA-Z0-9]/g, '-').substring(0, 30);
            link.download = `${safeName}-${index + 1}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            resolve();
          };
          img.onerror = () => {
            URL.revokeObjectURL(url);
            resolve();
          };
          img.src = url;
        });
      };

      // Export all favorites as PNGs
      const exportAllFavorites = async () => {
        for (let i = 0; i < favorites.length; i++) {
          await new Promise(resolve => setTimeout(resolve, 100)); // Small delay between downloads
          await exportFavoriteAsPng(favorites[i], i);
        }
      };

      // Use a ref to hold the log setter to avoid closure issues
      const logRef = React.useRef([]);

      // Log messages go to ref during render, then get flushed
      const logMessage = (level, message, context = {}) => {
        const timestamp = new Date().toLocaleTimeString();
        const entry = { timestamp, message, context, level, id: Date.now() + Math.random() };
        logRef.current = [...logRef.current, entry].slice(-50);
        if (level === 'error') {
          console.error(`[Sigil Error] ${message}`, context);
        } else if (level === 'warn') {
          console.warn(`[Sigil Warn] ${message}`, context);
        } else {
          console.log(`[Sigil Info] ${message}`, context);
        }
      };

      const logError = (message, context = {}) => logMessage('error', message, context);
      const logWarn = (message, context = {}) => logMessage('warn', message, context);
      const logInfo = (message, context = {}) => logMessage('info', message, context);

      const clearErrorLog = () => {
        setErrorLog([]);
        logRef.current = [];
      };

      // Clear log when text changes to avoid accumulation
      const lastTextRef = React.useRef('');
      React.useEffect(() => {
        if (currentText !== lastTextRef.current) {
          logRef.current = [];
          lastTextRef.current = currentText;
        }
      }, [currentText]);

      // Sync ref to state after render
      React.useEffect(() => {
        if (logRef.current.length > 0 && logRef.current.length !== errorLog.length) {
          setErrorLog([...logRef.current]);
        }
      });

      const examples = [
        { label: "Stability", text: "i have the stable resources needed to thrive" },
        { label: "Protection", text: "protection and strength in all things" },
        { label: "Release", text: "let go of what no longer serves my growth" },
        { label: "Abundance", text: "manifest abundance and prosperity today" },
        { label: "Clarity", text: "clarity and focus" },
        { label: "Creativity", text: "creative flow" },
      ];

      const toggleArrayValue = (setter) => (value) => {
        setter(prev => {
          if (prev.includes(value)) {
            return prev.filter(v => v !== value);
          }
          const newArr = [...prev, value];
          // Only sort if all values are numbers
          if (newArr.every(v => typeof v === 'number')) {
            return newArr.sort((a, b) => a - b);
          }
          return newArr;
        });
      };

      // Get current text based on active tab
      const currentText = activeTab === 0 ? customText : examples[activeTab - 1]?.text || '';
      const processed = currentText.length > 1 ? processText(currentText) : null;

      // Generate all combinations of selected options, organized by layout type
      const generateSigilsForText = (proc) => {
        if (!proc || proc.numbers.length < 2) return { layoutSections: {}, bestSigil: null, total: 0, filteredTotal: 0, uniqueTotal: 0 };

        const displaySize = getSize(SIZE_RATIOS.cardDisplay);
        const genSize = getSize(SIZE_RATIOS.genSize);
        const allSigils = [];

        // Generate Standard sigils
        if (standardEnabled) {
          for (const ppr of standardPointsPerRing) {
            const sigil = generateSigil(proc.unique, proc.numbers, genSize, ppr, LayoutMode.STANDARD);
            const heat = analyzeHeatMap(sigil.allIntersections, genSize);
            const actualRings = sigil.rings.length;

            if (standardRingCounts.includes(actualRings)) {
              const intersectionCount = sigil.allIntersections.length;
              allSigils.push({
                sigil, pointsPerRing: ppr, ringCount: actualRings,
                layoutType: 'standard', layoutLabel: 'Standard',
                heatScore: heat.globalScore, intersectionCount,
                isHot: heat.isHot, isPerfect: intersectionCount <= 1,
                heatAnalysis: heat, displaySize,
                description: `${ppr}/ring  ${actualRings} ring${actualRings !== 1 ? 's' : ''}`
              });
            }
          }
        }

        // Generate Venn sigils
        if (vennEnabled) {
          for (const ppr of vennPointsPerRing) {
            for (const circles of vennCircleCounts) {
              const sigil = generateSigilWithOptions(proc.unique, proc.numbers, genSize, ppr, 'venn', { circleCount: circles });
              const heat = analyzeHeatMap(sigil.allIntersections, genSize);
              const intersectionCount = sigil.allIntersections.length;

              allSigils.push({
                sigil, pointsPerRing: ppr, circleCount: circles,
                layoutType: 'venn', layoutLabel: 'Venn',
                heatScore: heat.globalScore, intersectionCount,
                isHot: heat.isHot, isPerfect: intersectionCount <= 1,
                heatAnalysis: heat, displaySize,
                description: `${ppr}/ring  ${circles} circles`
              });
            }
          }
        }

        // Generate Satellite sigils
        if (satelliteEnabled) {
          for (const ppr of satellitePointsPerRing) {
            for (const mainRings of satelliteMainRings) {
              for (const satRings of satelliteSatRings) {
                const sigil = generateSigilWithOptions(proc.unique, proc.numbers, genSize, ppr, 'satellite', { mainRings, satRings });
                const heat = analyzeHeatMap(sigil.allIntersections, genSize);
                const intersectionCount = sigil.allIntersections.length;

                allSigils.push({
                  sigil, pointsPerRing: ppr, mainRings, satRings,
                  layoutType: 'satellite', layoutLabel: 'Satellite',
                  heatScore: heat.globalScore, intersectionCount,
                  isHot: heat.isHot, isPerfect: intersectionCount <= 1,
                  heatAnalysis: heat, displaySize,
                  description: `${ppr}/ring  ${mainRings}m+${satRings}s`
                });
              }
            }
          }
        }

        // Generate Chained sigils - use larger canvas since chains need more space
        const chainedGenSize = getSize(SIZE_RATIOS.chainedGen);
        const chainedDisplaySize = getSize(SIZE_RATIOS.chainedDisplay);

        // Check if characters were deleted (need to reset locked rings)
        const currentUniqueStr = proc.unique.join('');
        const prevUniqueStr = prevUniqueRef.current;
        const isAdditionOnly = currentUniqueStr.startsWith(prevUniqueStr);

        if (!isAdditionOnly) {
          // Characters were deleted or reordered - clear all locked rings
          chainedLockedRingsRef.current = {};
        }
        prevUniqueRef.current = currentUniqueStr;

        if (chainedEnabled) {
          for (const ppr of chainedPointsPerRing) {
            for (const showDots of chainedShowJunctionDots) {
              try {
                // Get locked rings for this ppr (if any)
                // Only FULL rings (at ppr capacity) get locked
                const lockedRings = isAdditionOnly ? chainedLockedRingsRef.current[ppr] : null;

                const sigil = generateSigilWithOptions(proc.unique, proc.numbers, chainedGenSize, ppr, 'chained', {
                  pointsPerRing: ppr,
                  showJunctionDots: showDots,
                  lockedRings
                });

                // Validate sigil has required properties
                if (!sigil || !sigil.paths) {
                  logError(`Chained sigil generation returned invalid result`, { ppr, showDots, charCount: proc.unique.length });
                  continue;
                }

                // Store FULL rings (at capacity) for locking
                if (sigil.layout && sigil.layout.ringData && sigil.ringCenters) {
                  const fullRings = [];
                  const prevLocked = chainedLockedRingsRef.current[ppr] || [];
                  for (let ri = 0; ri < sigil.ringCenters.length; ri++) {
                    const ringPoints = sigil.points.filter(p => p.group === `ring${ri}`);
                    if (ringPoints.length >= ppr) {
                      // This ring is full - lock it
                      const wasLocked = prevLocked.some(lr =>
                        lr.chars.length === ringPoints.length &&
                        lr.chars.every((c, i) => c === ringPoints[i].letter)
                      );
                      if (!wasLocked) {
                        console.log(`[Chained] Ring ${ri} is now FULL and LOCKED (${ringPoints.length} chars)`);
                      }
                      fullRings.push({
                        chars: ringPoints.map(p => p.letter),
                        numbers: ringPoints.map(p => p.number),
                        cx: sigil.ringCenters[ri].cx,
                        cy: sigil.ringCenters[ri].cy,
                        radius: sigil.ringCenters[ri].radius
                      });
                    }
                  }
                  chainedLockedRingsRef.current[ppr] = fullRings;
                }

                const heat = analyzeHeatMap(sigil.allIntersections || [], chainedGenSize);
                const intersectionCount = (sigil.allIntersections || []).length;
                const numRings = sigil.ringCenters ? sigil.ringCenters.length : 1;

                // Only log warnings when fewer rings than expected
                const expectedMinGroups = Math.ceil(proc.unique.length / ppr);
                if (numRings < expectedMinGroups && proc.unique.length > ppr) {
                  logWarn(`Fewer rings than expected`, {
                    ppr, chars: proc.unique.length, expected: expectedMinGroups, got: numRings
                  });
                }

                allSigils.push({
                  sigil, pointsPerRing: ppr, showJunctionDots: showDots,
                  layoutType: 'chained', layoutLabel: 'Chained',
                  heatScore: heat.globalScore, intersectionCount,
                  isHot: heat.isHot, isPerfect: intersectionCount <= 1,
                  heatAnalysis: heat, displaySize: chainedDisplaySize,
                  description: `${ppr}/ring  ${numRings} ring${numRings !== 1 ? 's' : ''}${showDots ? ' +dots' : ''}`
                });
              } catch (err) {
                logError(`Chained sigil generation failed: ${err.message}`, { ppr, showDots, charCount: proc.unique.length, stack: err.stack });
              }
            }
          }
        }

        // Apply heat filter
        const filteredSigils = allSigils.filter(s => {
          if (heatFilter === 'perfect') return s.isPerfect;
          if (heatFilter === 'no-hot') return !s.isHot;
          return true;
        });

        // Find best sigil (fewest intersections) from filtered results
        const bestSigil = filteredSigils.length > 0
          ? filteredSigils.reduce((best, curr) => curr.intersectionCount < best.intersectionCount ? curr : best)
          : null;

        // Create visual hash for deduplication (based on path data)
        const getVisualHash = (sigil) => {
          return sigil.sigil.paths.map(p => p.d).join('|');
        };

        // Group and deduplicate sigils
        const deduplicateSigils = (sigils) => {
          const groups = new Map();
          for (const item of sigils) {
            const hash = getVisualHash(item);
            if (!groups.has(hash)) {
              groups.set(hash, { representative: item, items: [item] });
            } else {
              groups.get(hash).items.push(item);
            }
          }
          return Array.from(groups.values()).map(g => ({
            ...g.representative,
            stackCount: g.items.length,
            stackedItems: g.items
          }));
        };

        // Organize into sections by layout type
        const layoutSections = {
          standard: deduplicateSigils(filteredSigils.filter(s => s.layoutType === 'standard')),
          venn: deduplicateSigils(filteredSigils.filter(s => s.layoutType === 'venn')),
          satellite: deduplicateSigils(filteredSigils.filter(s => s.layoutType === 'satellite')),
          chained: deduplicateSigils(filteredSigils.filter(s => s.layoutType === 'chained')),
        };

        // Sort each section by intersection count
        Object.values(layoutSections).forEach(arr => arr.sort((a, b) => a.intersectionCount - b.intersectionCount));

        // Count total unique
        const uniqueTotal = Object.values(layoutSections).reduce((sum, arr) => sum + arr.length, 0);

        return { layoutSections, bestSigil, total: allSigils.length, filteredTotal: filteredSigils.length, uniqueTotal };
      };

      const { layoutSections, bestSigil, total, filteredTotal, uniqueTotal } = generateSigilsForText(processed);

      const layoutTitles = {
        standard: 'Standard',
        venn: 'Venn',
        satellite: 'Satellite',
        chained: 'Chained'
      };

      return (
        <div className={`app-container ${darkMode ? 'dark-mode' : ''}`}>
          <div className="tabs-bar">
            <div className="tabs-bar-left">
              <button
                className={`tab ${activeTab === 0 ? 'active' : ''}`}
                onClick={() => setActiveTab(0)}
              >
                Custom
              </button>
              <button
                className="examples-toggle"
                onClick={() => setExamplesExpanded(!examplesExpanded)}
              >
                <span className={`collapse-icon ${examplesExpanded ? 'expanded' : ''}`}></span>
                Examples
              </button>
              {examplesExpanded && examples.map((ex, i) => (
                <button
                  key={i}
                  className={`tab ${activeTab === i + 1 ? 'active' : ''}`}
                  onClick={() => setActiveTab(i + 1)}
                >
                  {ex.label}
                </button>
              ))}
            </div>

            <div className="tabs-bar-right">
              {/* Dark mode toggle */}
              <button
                className="topbar-toggle"
                onClick={() => setDarkMode(!darkMode)}
                title={darkMode ? 'Switch to light mode' : 'Switch to dark mode'}
              >
                {darkMode ? ' Light' : ' Dark'}
              </button>

              {/* Error Log */}
              <div className="error-log-container">
                <button
                  className={`topbar-toggle ${errorLog.some(e => e.level === 'error') ? 'has-errors' : ''}`}
                  onClick={() => setErrorLogExpanded(!errorLogExpanded)}
                >
                  {errorLogExpanded ? '' : ''} Log
                  {errorLog.length > 0 && (
                    <span className="error-log-badge" style={{marginLeft: getSize(SIZE_RATIOS.sp5xs)}}>{errorLog.length}</span>
                  )}
                </button>
                {errorLogExpanded && (
                  <div className="error-log-dropdown">
                    <div className="error-log-panel">
                      <div className="error-log-header">
                        <span className="error-log-title">Generation Log</span>
                        {errorLog.length > 0 && (
                          <span className="error-log-clear" onClick={clearErrorLog}>Clear</span>
                        )}
                      </div>
                      <div className="error-log-content">
                        {errorLog.length === 0 ? (
                          <div className="error-log-empty">No messages logged</div>
                        ) : (
                          errorLog.slice().reverse().map(entry => (
                            <div key={entry.id} className={`error-log-item level-${entry.level || 'error'}`}>
                              <span className="error-log-timestamp">[{entry.timestamp}]</span>
                              <span className={`log-level-badge ${entry.level || 'error'}`}>{entry.level || 'error'}</span>
                              {entry.message}
                              {entry.context && Object.keys(entry.context).length > 0 && (
                                <div style={{marginTop: getSize(SIZE_RATIOS.sp5xs), fontSize: getSize(SIZE_RATIOS.fontTiny), opacity: 0.8}}>
                                  {JSON.stringify(entry.context)}
                                </div>
                              )}
                            </div>
                          ))
                        )}
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* Mobile fixed header - dark mode toggle and log */}
          <div className="mobile-header">
            <button
              className="mobile-header-btn"
              onClick={() => setDarkMode(!darkMode)}
            >
              {darkMode ? '' : ''}
            </button>
            <span className="mobile-header-title">Sigil Generator</span>
            <button
              className={`mobile-header-btn ${errorLog.length > 0 ? 'has-badge' : ''}`}
              onClick={() => setErrorLogExpanded(!errorLogExpanded)}
            >
               {errorLog.length > 0 && <span className="mobile-badge">{errorLog.length}</span>}
            </button>
          </div>

          {/* Mobile input section - fixed below header */}
          <div className="mobile-input-section">
            <input
              type="text"
              value={customText}
              onChange={(e) => setCustomText(e.target.value)}
              placeholder="Enter your phrase..."
            />
            {processed && (
              <div className="mobile-input-info">
                <strong>{processed.unique.length}</strong> unique: {processed.unique.join('')}
              </div>
            )}
          </div>

          {/* Mobile floating buttons - fixed at bottom */}
          <div className="mobile-floating-buttons">
            <button
              className={`mobile-floating-btn ${mobileControlsOpen ? 'active' : ''}`}
              onClick={() => {
                setMobileControlsOpen(!mobileControlsOpen);
                setShowcaseExpanded(false);
              }}
            >
               Controls
            </button>
            <button
              className={`mobile-floating-btn ${showcaseExpanded ? 'active' : ''}`}
              onClick={() => {
                setShowcaseExpanded(true);
                setMobileControlsOpen(false);
              }}
            >
               Showcase
            </button>
          </div>

          <div className="app-layout">
            <div className={`left-panel ${mobileControlsOpen ? 'mobile-open' : ''}`}>
              <h1>Sigil Generator</h1>

              {activeTab === 0 && (
                <div className="section">
                  <input
                    type="text"
                    value={customText}
                    onChange={(e) => setCustomText(e.target.value)}
                    placeholder="Enter your phrase..."
                  />
                </div>
              )}

              {activeTab !== 0 && (
                <div className="section">
                  <div className="info" style={{marginTop: 0, fontSize: getSize(SIZE_RATIOS.fontTertiary)}}>
                    "{currentText}"
                  </div>
                </div>
              )}

              {processed && (
                <div className="info" style={{marginBottom: getSize(SIZE_RATIOS.spXs)}}>
                  <strong>{processed.unique.length}</strong> letters: {processed.unique.join('')}
                </div>
              )}

              <div className="display-toggles">
                <label className="display-toggle">
                  <input type="checkbox" checked={showGuides} onChange={(e) => setShowGuides(e.target.checked)} />
                  Guides
                </label>
                <label className="display-toggle">
                  <input type="checkbox" checked={showDots} onChange={(e) => setShowDots(e.target.checked)} />
                  Dots
                </label>
                <label className="display-toggle">
                  <input type="checkbox" checked={showLabels} onChange={(e) => setShowLabels(e.target.checked)} />
                  Labels
                </label>
                <label className="display-toggle">
                  <input type="checkbox" checked={showHeatMap} onChange={(e) => setShowHeatMap(e.target.checked)} />
                  Heat
                </label>
              </div>

              <div className="section">
                <div className="section-title">Filter</div>
                <div className="filter-group">
                  <button className={`filter-btn ${heatFilter === 'all' ? 'active' : ''}`} onClick={() => setHeatFilter('all')}>All</button>
                  <button className={`filter-btn perfect-filter ${heatFilter === 'perfect' ? 'active' : ''}`} onClick={() => setHeatFilter('perfect')}>Perfect</button>
                  <button className={`filter-btn ${heatFilter === 'no-hot' ? 'active' : ''}`} onClick={() => setHeatFilter('no-hot')}>No Hot</button>
                </div>
              </div>

              <div className="section layout-section">
                <div className="collapsible-header" onClick={() => setStandardExpanded(!standardExpanded)}>
                  <label style={{display: 'inline-flex', alignItems: 'center', gap: getSize(SIZE_RATIOS.sp4xs)}} onClick={(e) => e.stopPropagation()}>
                    <input type="checkbox" checked={standardEnabled} onChange={(e) => setStandardEnabled(e.target.checked)} />
                    Standard
                  </label>
                  <span className={`collapse-icon ${standardExpanded ? 'expanded' : ''}`}></span>
                </div>
                {standardEnabled && standardExpanded && (
                  <div className="collapsible-content">
                    <div className="subsection">
                      <div className="subsection-label">Points/Ring</div>
                      <div className="toggle-group">
                        {pointsPerRingOptions.map(n => (
                          <button key={n} className={`toggle-btn ${standardPointsPerRing.includes(n) ? 'active' : ''}`}
                            onClick={() => toggleArrayValue(setStandardPointsPerRing)(n)}>{n}</button>
                        ))}
                      </div>
                    </div>
                    <div className="subsection">
                      <div className="subsection-label">Rings</div>
                      <div className="toggle-group">
                        {ringCountOptions.map(n => (
                          <button key={n} className={`toggle-btn ${standardRingCounts.includes(n) ? 'active' : ''}`}
                            onClick={() => toggleArrayValue(setStandardRingCounts)(n)}>{n}</button>
                        ))}
                      </div>
                    </div>
                  </div>
                )}
              </div>

              <div className="section layout-section">
                <div className="collapsible-header" onClick={() => setVennExpanded(!vennExpanded)}>
                  <label style={{display: 'inline-flex', alignItems: 'center', gap: getSize(SIZE_RATIOS.sp4xs)}} onClick={(e) => e.stopPropagation()}>
                    <input type="checkbox" checked={vennEnabled} onChange={(e) => setVennEnabled(e.target.checked)} />
                    Venn
                  </label>
                  <span className={`collapse-icon ${vennExpanded ? 'expanded' : ''}`}></span>
                </div>
                {vennEnabled && vennExpanded && (
                  <div className="collapsible-content">
                    <div className="subsection">
                      <div className="subsection-label">Points/Ring</div>
                      <div className="toggle-group">
                        {pointsPerRingOptions.map(n => (
                          <button key={n} className={`toggle-btn ${vennPointsPerRing.includes(n) ? 'active' : ''}`}
                            onClick={() => toggleArrayValue(setVennPointsPerRing)(n)}>{n}</button>
                        ))}
                      </div>
                    </div>
                    <div className="subsection">
                      <div className="subsection-label">Circles</div>
                      <div className="toggle-group">
                        {vennCircleOptions.map(n => (
                          <button key={n} className={`toggle-btn ${vennCircleCounts.includes(n) ? 'active' : ''}`}
                            onClick={() => toggleArrayValue(setVennCircleCounts)(n)}>{n}</button>
                        ))}
                      </div>
                    </div>
                  </div>
                )}
              </div>

              <div className="section layout-section">
                <div className="collapsible-header" onClick={() => setSatelliteExpanded(!satelliteExpanded)}>
                  <label style={{display: 'inline-flex', alignItems: 'center', gap: getSize(SIZE_RATIOS.sp4xs)}} onClick={(e) => e.stopPropagation()}>
                    <input type="checkbox" checked={satelliteEnabled} onChange={(e) => setSatelliteEnabled(e.target.checked)} />
                    Satellite
                  </label>
                  <span className={`collapse-icon ${satelliteExpanded ? 'expanded' : ''}`}></span>
                </div>
                {satelliteEnabled && satelliteExpanded && (
                  <div className="collapsible-content">
                    <div className="subsection">
                      <div className="subsection-label">Points/Ring</div>
                      <div className="toggle-group">
                        {pointsPerRingOptions.map(n => (
                          <button key={n} className={`toggle-btn ${satellitePointsPerRing.includes(n) ? 'active' : ''}`}
                            onClick={() => toggleArrayValue(setSatellitePointsPerRing)(n)}>{n}</button>
                        ))}
                      </div>
                    </div>
                    <div className="subsection">
                      <div className="subsection-label">Main Rings</div>
                      <div className="toggle-group">
                        {satelliteRingOptions.map(n => (
                          <button key={n} className={`toggle-btn ${satelliteMainRings.includes(n) ? 'active' : ''}`}
                            onClick={() => toggleArrayValue(setSatelliteMainRings)(n)}>{n}</button>
                        ))}
                      </div>
                    </div>
                    <div className="subsection">
                      <div className="subsection-label">Satellite Rings</div>
                      <div className="toggle-group">
                        {satelliteRingOptions.map(n => (
                          <button key={n} className={`toggle-btn ${satelliteSatRings.includes(n) ? 'active' : ''}`}
                            onClick={() => toggleArrayValue(setSatelliteSatRings)(n)}>{n}</button>
                        ))}
                      </div>
                    </div>
                  </div>
                )}
              </div>

              <div className="section layout-section">
                <div className="collapsible-header" onClick={() => setChainedExpanded(!chainedExpanded)}>
                  <label style={{display: 'inline-flex', alignItems: 'center', gap: getSize(SIZE_RATIOS.sp4xs)}} onClick={(e) => e.stopPropagation()}>
                    <input type="checkbox" checked={chainedEnabled} onChange={(e) => setChainedEnabled(e.target.checked)} />
                    Chained
                  </label>
                  <span className={`collapse-icon ${chainedExpanded ? 'expanded' : ''}`}></span>
                </div>
                {chainedEnabled && chainedExpanded && (
                  <div className="collapsible-content">
                    <div className="subsection">
                      <div className="subsection-label">Points/Ring</div>
                      <div className="toggle-group">
                        {chainedPointsOptions.map(n => (
                          <button key={n} className={`toggle-btn ${chainedPointsPerRing.includes(n) ? 'active' : ''}`}
                            onClick={() => toggleArrayValue(setChainedPointsPerRing)(n)}>{n}</button>
                        ))}
                      </div>
                    </div>
                    <div className="subsection">
                      <div className="subsection-label">Junction Dots</div>
                      <div className="toggle-group">
                        <button className={`toggle-btn ${chainedShowJunctionDots.includes(true) ? 'active' : ''}`}
                          onClick={() => toggleArrayValue(setChainedShowJunctionDots)(true)}>Show</button>
                        <button className={`toggle-btn ${chainedShowJunctionDots.includes(false) ? 'active' : ''}`}
                          onClick={() => toggleArrayValue(setChainedShowJunctionDots)(false)}>Hide</button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>

            <div className="right-panel">
              <div className="results-header">
                Generated Sigils
                <span className="results-count">
                  ({uniqueTotal || 0} unique{uniqueTotal !== filteredTotal ? ` / ${filteredTotal} variations` : ''}{heatFilter !== 'all' ? ` of ${total} total` : ''})
                </span>
                {bestSigil && <span className="best-badge">Best: {bestSigil.description}</span>}
              </div>

              {favorites.length > 0 && (
                <div className="favorites-tab">
                  <div className="favorites-header">
                    <h3>Favorites ({favorites.length})</h3>
                    <div>
                      <button className="export-btn" onClick={exportAllFavorites} disabled={favorites.length === 0}>
                        Export All as PNG
                      </button>
                      <button className="clear-favorites-btn" onClick={() => setFavorites([])}>
                        Clear All
                      </button>
                    </div>
                  </div>
                  <div className="favorites-grid">
                    {(() => {
                      const otherFavs = favorites.filter(f => f && f.sigil && f.layoutType !== 'chained' && f.sigil.layoutMode !== 'chained');
                      const chainedFavs = favorites.filter(f => f && f.sigil && (f.layoutType === 'chained' || f.sigil.layoutMode === 'chained'));

                      const renderFavorite = (fav, idx) => (
                        <div key={fav.id || idx} className="sigil-card favorite" onClick={(e) => { e.preventDefault(); e.stopPropagation(); toggleFavorite(fav); }} style={{position: 'relative'}}>
                          <SigilSVG
                            sigil={fav.sigil}
                            size={fav.displaySize || getSize(SIZE_RATIOS.favDisplay)}
                            generatedSize={fav.sigil.size || getSize(SIZE_RATIOS.genSize)}
                            showGuides={fav.showGuides ?? false}
                            showDots={fav.showDots ?? false}
                            showLabels={fav.showLabels ?? false}
                            showHeatMap={fav.showHeatMap ?? false}
                            svgId={`favorite-svg-${idx}`}
                            darkMode={darkMode}
                          />
                          <div className="sigil-label">
                            {fav.phrase && <span style={{fontWeight: 'bold'}}>{fav.phrase}</span>}
                            <br />
                            <span style={{opacity: 0.7}}>{fav.description || ''}</span>
                          </div>
                          <button
                            className="export-btn"
                            style={{position: 'absolute', top: getSize(SIZE_RATIOS.sp5xs), right: getSize(SIZE_RATIOS.sp5xs), padding: `${getSize(SIZE_RATIOS.radius2xs)}px ${getSize(SIZE_RATIOS.sp4xs)}px`, fontSize: getSize(SIZE_RATIOS.fontSmall)}}
                            onClick={(e) => { e.stopPropagation(); exportFavoriteAsPng(fav, idx); }}
                          >
                            PNG
                          </button>
                        </div>
                      );

                      return (
                        <>
                          {otherFavs.length > 0 && (
                            <>
                              {chainedFavs.length > 0 && <div className="favorites-section-label">Standard / Venn / Satellite</div>}
                              {otherFavs.map((fav, i) => renderFavorite(fav, `other-${i}`))}
                            </>
                          )}
                          {chainedFavs.length > 0 && (
                            <>
                              <div className="favorites-section-label">Chained</div>
                              {chainedFavs.map((fav, i) => renderFavorite(fav, `chained-${i}`))}
                            </>
                          )}
                        </>
                      );
                    })()}
                  </div>
                </div>
              )}

              {!processed || processed.numbers.length < 2 ? (
                <div className="no-results">
                  {activeTab === 0
                    ? "Enter a phrase with at least 2 unique consonants"
                    : "Select a tab with a valid phrase"
                  }
                </div>
              ) : filteredTotal === 0 ? (
                <div className="no-results">
                  {heatFilter === 'perfect'
                    ? "No perfect sigils found. Try different settings or switch filter to 'All'."
                    : heatFilter === 'no-hot'
                    ? "All sigils have hot zones. Try different settings or switch filter to 'All'."
                    : "No sigils match the selected options. Enable at least one layout type."
                  }
                </div>
              ) : (
                ['standard', 'venn', 'satellite', 'chained'].map(layoutType => {
                  const sigils = layoutSections[layoutType];
                  if (!sigils || sigils.length === 0) return null;
                  const sectionTotal = sigils.reduce((sum, s) => sum + (s.stackCount || 1), 0);

                  return (
                    <div key={layoutType} className="results-section">
                      <div className="results-section-title">
                        {layoutTitles[layoutType]} Layout
                        <span className="results-count" style={{marginLeft: getSize(SIZE_RATIOS.sp3xs)}}>
                          ({sigils.length}{sectionTotal !== sigils.length ? ` unique / ${sectionTotal}` : ''})
                        </span>
                      </div>

                      <div className="results-grid" style={{marginTop: getSize(SIZE_RATIOS.spXs)}}>
                        {sigils.map((item, i) => {
                          const isBest = bestSigil && item.sigil === bestSigil.sigil;
                          const stackCount = item.stackCount || 1;
                          const stackClass = stackCount === 2 ? 'stacked-2' : stackCount >= 3 ? 'stacked-many' : '';
                          const isFav = isFavorite(item);
                          const hidden = isHidden(item);

                          if (hidden) {
                            // Match height to visible card (canvas + padding + label area)
                            const cardHeight = (item.displaySize || getSize(SIZE_RATIOS.favDisplay)) + getSize(0.136);
                            return (
                              <div key={i} className="sigil-card-hidden" style={{height: cardHeight}} onClick={(e) => toggleHidden(item, e)} title={`Click to show: ${item.description}`} />
                            );
                          }

                          return (
                            <div key={i} className={`sigil-card-wrapper ${stackClass}`}>
                              {stackCount > 1 && <span className="stack-count">{stackCount}</span>}
                              <div
                                className={`sigil-card ${item.isPerfect ? 'perfect' : ''} ${isFav ? 'favorite' : ''}`}
                                onClick={(e) => { e.preventDefault(); e.stopPropagation(); setSelectedSigil({...item, phrase: currentText}); setShowcaseExpanded(true); }}
                                title="Click to view in showcase"
                              >
                                <button className="hide-btn" onClick={(e) => toggleHidden(item, e)} title="Hide this sigil">Hide</button>
                                <button
                                  className={`showcase-btn ${selectedSigil && selectedSigil.id === item.id ? 'active' : ''}`}
                                  onClick={(e) => { e.stopPropagation(); setSelectedSigil({...item, phrase: currentText}); setShowcaseExpanded(true); }}
                                  title="View in showcase"
                                  style={{
                                    position: 'absolute', top: '4px', right: '26px',
                                    background: 'none', border: 'none', cursor: 'pointer',
                                    fontSize: '14px', padding: 0, width: '18px', height: '18px',
                                    lineHeight: '18px', textAlign: 'center',
                                    opacity: selectedSigil && selectedSigil.id === item.id ? 1 : 0, transition: 'opacity 0.2s'
                                  }}
                                >
                                  {selectedSigil && selectedSigil.id === item.id ? '' : ''}
                                </button>
                                <button
                                  className="fav-btn"
                                  onClick={(e) => { e.stopPropagation(); toggleFavorite(item); }}
                                  title={isFav ? 'Remove from favorites' : 'Add to favorites'}
                                  style={{
                                    position: 'absolute', top: '4px', right: '4px',
                                    background: 'none', border: 'none', cursor: 'pointer',
                                    fontSize: '14px', padding: 0, width: '18px', height: '18px',
                                    lineHeight: '18px', textAlign: 'center',
                                    opacity: isFav ? 1 : 0, transition: 'opacity 0.2s'
                                  }}
                                >
                                  {isFav ? '' : ''}
                                </button>
                                <SigilSVG
                                  sigil={item.sigil}
                                  size={item.displaySize}
                                  generatedSize={item.sigil.size}
                                  showGuides={showGuides}
                                  showDots={showDots}
                                  showLabels={showLabels}
                                  showHeatMap={showHeatMap}
                                  heatAnalysis={item.heatAnalysis}
                                  darkMode={darkMode}
                                />
                                <div className={`sigil-label ${isBest ? 'recommended' : ''}`}>
                                  {item.description}
                                  {item.isHot && <span className="hot-warning">  HOT</span>}
                                  <br />
                                  <span style={{opacity: 0.7}}>{item.intersectionCount} intersection{item.intersectionCount !== 1 ? 's' : ''}</span>
                                  {isBest && ' '}
                                </div>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  );
                })
              )}
            </div>

            {/* Showcase Panel */}
            {(() => {
              // Showcase toggle acts as override - XOR logic
              // Global light + toggle off = light, Global light + toggle on = dark
              // Global dark + toggle off = dark, Global dark + toggle on = light (override)
              const effectiveShowcaseDark = darkMode !== showcaseDarkMode;
              return (
            <div
              className={`detail-panel ${!showcaseExpanded ? 'collapsed' : ''} ${effectiveShowcaseDark ? 'showcase-dark' : ''}`}
              onClick={() => !showcaseExpanded && setShowcaseExpanded(true)}
            >
              {!showcaseExpanded ? (
                <span className="detail-panel-collapsed-label">SHOWCASE</span>
              ) : (
                <>
                  {/* Header with controls */}
                  <div className="detail-panel-header">
                    <span className="detail-panel-title">Showcase</span>
                    <div className="detail-panel-controls">
                      <button
                        className={`detail-panel-btn ${printPreview ? 'active' : ''}`}
                        onClick={() => setPrintPreview(!printPreview)}
                        title={printPreview ? 'Normal view' : 'Print preview (thick lines)'}
                      >
                        {printPreview ? '' : ''}
                      </button>
                      {printPreview && selectedSigil && (
                        <button
                          className="detail-panel-btn print-btn"
                          onClick={async () => {
                            const container = document.querySelector('.detail-sigil-container');
                            if (container && window.html2canvas) {
                              try {
                                // Temporarily reset transform for accurate capture
                                const wrapper = document.querySelector('.showcase-scaled-wrapper');
                                const originalTransform = wrapper ? wrapper.style.transform : '';
                                if (wrapper) wrapper.style.transform = 'none';

                                const canvas = await window.html2canvas(container, {
                                  backgroundColor: effectiveShowcaseDark ? '#1a1a1a' : '#fafaf9',
                                  scale: 2,
                                  useCORS: true,
                                  logging: false,
                                  scrollX: 0,
                                  scrollY: 0,
                                  windowWidth: container.scrollWidth,
                                  windowHeight: container.scrollHeight
                                });

                                // Restore transform
                                if (wrapper) wrapper.style.transform = originalTransform;

                                const imgData = canvas.toDataURL('image/png');
                                const printWindow = window.open('', '_blank');
                                if (printWindow) {
                                  const bg = effectiveShowcaseDark ? '#1a1a1a' : '#fafaf9';
                                  printWindow.document.write(`
                                    <html>
                                      <head>
                                        <title>Print Sigil</title>
                                        <style>
                                          * { margin: 0; padding: 0; box-sizing: border-box; }
                                          body { background: ${bg}; display: flex; justify-content: center; padding: 20px; }
                                          img { max-width: 100%; height: auto; }
                                          @media print {
                                            body { padding: 0; }
                                            img { max-height: 95vh; width: auto; }
                                            @page { margin: 0.3cm; size: auto; }
                                          }
                                        </style>
                                      </head>
                                      <body><img src="${imgData}" /></body>
                                    </html>
                                  `);
                                  printWindow.document.close();
                                  printWindow.focus();
                                  setTimeout(() => printWindow.print(), 300);
                                }
                              } catch (err) {
                                console.error('Print error:', err);
                                alert('Error generating print image');
                              }
                            }
                          }}
                          title="Print showcase"
                        >
                          Print
                        </button>
                      )}
                      <button
                        className="detail-panel-btn"
                        onClick={() => setShowcaseDarkMode(!showcaseDarkMode)}
                        title={effectiveShowcaseDark ? 'Light background' : 'Dark background'}
                      >
                        {effectiveShowcaseDark ? '' : ''}
                      </button>
                      <button
                        className="detail-panel-btn"
                        onClick={() => setShowcaseExpanded(false)}
                        title="Collapse panel"
                      >
                        
                      </button>
                    </div>
                  </div>

                  {selectedSigil ? (() => {
                    // Calculate header line count for sizing
                    const phrase = (selectedSigil.phrase || currentText).toUpperCase();
                    const words = phrase.split(' ');
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    ctx.font = `300 36px Didot, "Bodoni MT", "Playfair Display", "Times New Roman", serif`;
                    const baseTextWidth = ctx.measureText(phrase).width + (5 * (phrase.length - 1));
                    const targetWidth = BASE_SIZE * 0.95;
                    const hasThreeLineHeader = baseTextWidth > targetWidth * 2.0 && words.length >= 3;

                    return (
                    <div className={`detail-content ${printPreview ? 'print-mode' : ''} ${hasThreeLineHeader ? 'three-line-header' : ''}`}>
                      <div className="showcase-scaled-wrapper">
                      <div className="detail-sigil-container" style={{width: BASE_SIZE}}>
                        {/* Arched phrase using SVG */}
                        <div className="detail-phrase-arch">
                          {(() => {
                            const phrase = (selectedSigil.phrase || currentText).toUpperCase();
                            const words = phrase.split(' ');

                            // Measure text width using canvas
                            const measureTextWidth = (text, fontSize, letterSpacing) => {
                              const canvas = document.createElement('canvas');
                              const ctx = canvas.getContext('2d');
                              ctx.font = `300 ${fontSize}px Didot, "Bodoni MT", "Playfair Display", "Times New Roman", serif`;
                              const baseWidth = ctx.measureText(text).width;
                              // Add letter spacing (letterSpacing * number of gaps between chars)
                              return baseWidth + (letterSpacing * (text.length - 1));
                            };

                            // Header arc endpoints should match sigil/divider width
                            // Use BASE_SIZE for viewBox calculations (SVG scales via CSS)
                            const headerWidth = BASE_SIZE;
                            const targetWidth = headerWidth * 0.95; // Text fills 95% of viewBox width

                            // Calculate font size and letter spacing to fill 95% of width
                            const calcTextParams = (text, minFontSize = 28, maxFontSize = 80) => {
                              let fontSize = minFontSize;
                              let letterSpacing = 10;
                              let width = measureTextWidth(text, fontSize, letterSpacing);

                              // Scale up font size until we approach target width
                              while (width < targetWidth * 0.9 && fontSize < maxFontSize) {
                                fontSize += 1;
                                letterSpacing = Math.max(10, fontSize * 0.6);
                                width = measureTextWidth(text, fontSize, letterSpacing);
                              }

                              // Fine-tune with letter spacing to hit target width
                              while (width < targetWidth && letterSpacing < fontSize * 2) {
                                letterSpacing += 1;
                                width = measureTextWidth(text, fontSize, letterSpacing);
                              }

                              // Step back if overshot
                              while (width > targetWidth && letterSpacing > 10) {
                                letterSpacing -= 1;
                                width = measureTextWidth(text, fontSize, letterSpacing);
                              }

                              return { fontSize, letterSpacing: Math.round(letterSpacing) };
                            };

                            const baseTextWidth = measureTextWidth(phrase, 36, 5);
                            const needsThreeLines = baseTextWidth > targetWidth * 2.0 && words.length >= 3;
                            const needsTwoLines = !needsThreeLines && baseTextWidth > targetWidth * 1.3 && words.length > 1;

                            // Standardized arc settings - concentric arcs for true parallel curves
                            const w = headerWidth;
                            const centerX = w / 2;
                            const decorOffset = 28; // Visual offset between text and decor lines

                            // DO NOT CHANGE THESE VALUES - arch settings are finalized
                            // baseRadius and centerY control the arch curve - DO NOT MODIFY
                            const baseRadius = 300;
                            const centerY = 180;

                            // Helper to create concentric arc at a given radius
                            const arc = (radius) => {
                              // Calculate start/end Y positions where arc intersects x=0 and x=w
                              const halfWidth = w / 2;
                              const yOffset = Math.sqrt(radius * radius - halfWidth * halfWidth);
                              const startY = centerY - yOffset;
                              return `M 0,${startY} A ${radius},${radius} 0 0,1 ${w},${startY}`;
                            };

                            // THREE LINES
                            if (needsThreeLines) {
                              // Split words into 3 roughly equal groups
                              const third = Math.ceil(words.length / 3);
                              const twoThirds = Math.ceil(words.length * 2 / 3);
                              const line1 = words.slice(0, third).join(' ');
                              const line2 = words.slice(third, twoThirds).join(' ');
                              const line3 = words.slice(twoThirds).join(' ');

                              // Find longest line for sizing
                              const longestLine = [line1, line2, line3].reduce((a, b) => a.length >= b.length ? a : b);
                              const { fontSize, letterSpacing } = calcTextParams(longestLine, 24, 72);

                              // Font metrics
                              const capHeight = fontSize * 0.72;
                              const descHeight = fontSize * 0.22;
                              const X = decorOffset;

                              // CALCULATED RADII for 3 lines (with print mode spacing)
                              const ps = printPreview ? 1 : 0; // print spacing multiplier
                              const lowerDecorRadius = 255 + (25 * ps);
                              const line3Radius = 255 + X + descHeight + (50 * ps);               // bottom text
                              const line2Radius = line3Radius + (X/2) + capHeight + descHeight + (25 * ps);   // middle text
                              const line1Radius = line2Radius + (X/2) + capHeight + descHeight + (25 * ps);   // top text
                              const upperDecorRadius = line1Radius + X + capHeight + (40 * ps);

                              const decorStroke = printPreview ? 6 : 0.5;
                              const printWeight = printPreview ? 900 : 300;
                              const printOpacity = printPreview ? 1 : 0.4;
                              const printFontSize = printPreview ? fontSize * 1.25 : fontSize;
                              // Text stroke for bold effect in print mode
                              const textStroke = printPreview ? 2 : 0;

                              return (
                                <svg width="100%" viewBox={`0 -95 ${w} 155`} style={{marginBottom: -85}} preserveAspectRatio="xMidYMid meet">
                                  <defs>
                                    <path id="textArc1" d={arc(line1Radius)} fill="none" />
                                    <path id="textArc2" d={arc(line2Radius)} fill="none" />
                                    <path id="textArc3" d={arc(line3Radius)} fill="none" />
                                  </defs>
                                  <path d={arc(upperDecorRadius)} fill="none" stroke="currentColor" strokeWidth={decorStroke} opacity={printOpacity} />
                                  <text fontSize={printFontSize} fontWeight={printWeight} textAnchor="middle" letterSpacing={letterSpacing} fill="currentColor" stroke="currentColor" strokeWidth={textStroke} paintOrder="stroke">
                                    <textPath href="#textArc1" startOffset="50%">{line1}</textPath>
                                  </text>
                                  <text fontSize={printFontSize} fontWeight={printWeight} textAnchor="middle" letterSpacing={letterSpacing} fill="currentColor" stroke="currentColor" strokeWidth={textStroke} paintOrder="stroke">
                                    <textPath href="#textArc2" startOffset="50%">{line2}</textPath>
                                  </text>
                                  <text fontSize={printFontSize} fontWeight={printWeight} textAnchor="middle" letterSpacing={letterSpacing} fill="currentColor" stroke="currentColor" strokeWidth={textStroke} paintOrder="stroke">
                                    <textPath href="#textArc3" startOffset="50%">{line3}</textPath>
                                  </text>
                                  <path d={arc(lowerDecorRadius)} fill="none" stroke="currentColor" strokeWidth={decorStroke} opacity={printOpacity} />
                                </svg>
                              );
                            }

                            // TWO LINES
                            if (needsTwoLines) {
                              const mid = Math.ceil(words.length / 2);
                              const line1 = words.slice(0, mid).join(' ');
                              const line2 = words.slice(mid).join(' ');
                              // Use params from the longer line so it fills the width
                              // Both lines use the same size for visual consistency
                              const longerLine = line1.length >= line2.length ? line1 : line2;
                              const { fontSize, letterSpacing } = calcTextParams(longerLine, 28, 96);

                              // Font metrics (approximate for typical sans-serif)
                              const capHeight = fontSize * 0.72;  // Height of uppercase letters above baseline
                              const descHeight = fontSize * 0.22; // Depth of descenders below baseline

                              // Spacing unit X (gap from decor to character edges)
                              const X = decorOffset;

                              // CALCULATED RADII - spacing measured at arc CENTER (with print mode spacing)
                              // At center: y = 180 - radius, so radius difference = y difference
                              const ps = printPreview ? 1 : 0; // print spacing multiplier
                              const lowerDecorRadius = 255 + (25 * ps);               // bottom decor
                              const line2Radius = 255 + X + descHeight + (50 * ps);  // lower text: gap X from decor to char bottoms
                              const line1Radius = line2Radius + (X/2) + capHeight + descHeight + (25 * ps);  // upper text
                              const upperDecorRadius = line1Radius + X + capHeight + (40 * ps);  // top decor

                              const decorStroke = printPreview ? 6 : 0.5;
                              const printWeight = printPreview ? 900 : 300;
                              const printOpacity = printPreview ? 1 : 0.4;
                              const printFontSize = printPreview ? fontSize * 1.25 : fontSize;
                              const textStroke = printPreview ? 2 : 0;

                              return (
                                <svg width="100%" viewBox={`0 -70 ${w} 130`} style={{marginBottom: -85}} preserveAspectRatio="xMidYMid meet">
                                  <defs>
                                    <path id="textArc1" d={arc(line1Radius)} fill="none" />
                                    <path id="textArc2" d={arc(line2Radius)} fill="none" />
                                  </defs>
                                  <path d={arc(upperDecorRadius)} fill="none" stroke="currentColor" strokeWidth={decorStroke} opacity={printOpacity} />
                                  <text fontSize={printFontSize} fontWeight={printWeight} textAnchor="middle" letterSpacing={letterSpacing} fill="currentColor" stroke="currentColor" strokeWidth={textStroke} paintOrder="stroke">
                                    <textPath href="#textArc1" startOffset="50%">{line1}</textPath>
                                  </text>
                                  <text fontSize={printFontSize} fontWeight={printWeight} textAnchor="middle" letterSpacing={letterSpacing} fill="currentColor" stroke="currentColor" strokeWidth={textStroke} paintOrder="stroke">
                                    <textPath href="#textArc2" startOffset="50%">{line2}</textPath>
                                  </text>
                                  <path d={arc(lowerDecorRadius)} fill="none" stroke="currentColor" strokeWidth={decorStroke} opacity={printOpacity} />
                                </svg>
                              );
                            }

                            // ONE LINE
                            const { fontSize, letterSpacing } = calcTextParams(phrase, 32, 96);

                            // Font metrics (approximate for typical sans-serif)
                            const capHeight = fontSize * 0.72;
                            const descHeight = fontSize * 0.22;

                            // Spacing unit X (gap from decor to character edges)
                            const X = decorOffset;

                            // CALCULATED RADII - spacing measured at arc CENTER (with print mode spacing)
                            const ps = printPreview ? 1 : 0; // print spacing multiplier
                            const lowerDecorRadius = 255 + (25 * ps);             // bottom decor
                            const textRadius = 255 + X + descHeight + (50 * ps); // text: gap X from decor to char bottoms
                            const upperDecorRadius = textRadius + X + capHeight + (40 * ps); // top decor

                            const decorStroke = printPreview ? 6 : 0.5;
                            const printWeight = printPreview ? 900 : 300;
                            const printOpacity = printPreview ? 1 : 0.4;
                            const printFontSize = printPreview ? fontSize * 1.25 : fontSize;
                            const textStroke = printPreview ? 2 : 0;

                            return (
                              <svg width="100%" viewBox={`0 -60 ${w} 110`} style={{marginBottom: -85}} preserveAspectRatio="xMidYMid meet">
                                <defs>
                                  <path id="textArc" d={arc(textRadius)} fill="none" />
                                </defs>
                                <path d={arc(upperDecorRadius)} fill="none" stroke="currentColor" strokeWidth={decorStroke} opacity={printOpacity} />
                                <text fontSize={printFontSize} fontWeight={printWeight} textAnchor="middle" letterSpacing={letterSpacing} fill="currentColor" stroke="currentColor" strokeWidth={textStroke} paintOrder="stroke">
                                  <textPath href="#textArc" startOffset="50%">{phrase}</textPath>
                                </text>
                                <path d={arc(lowerDecorRadius)} fill="none" stroke="currentColor" strokeWidth={decorStroke} opacity={printOpacity} />
                              </svg>
                            );
                          })()}
                        </div>

                        {/* Main sigil - big */}
                        <div className="detail-main-sigil">
                          <SigilSVG
                            sigil={selectedSigil.sigil}
                            size={BASE_SIZE}
                            generatedSize={selectedSigil.sigil.size || getSize(SIZE_RATIOS.genSize)}
                            showGuides={false}
                            showDots={showDots}
                            showLabels={false}
                            showHeatMap={false}
                            darkMode={effectiveShowcaseDark}
                            showCenterDot={false}
                            markerScale={2.25}
                            thinStroke={effectiveShowcaseDark && !printPreview}
                            printMode={printPreview}
                            pathStrokeMult={printPreview ? 2 : 1}
                            svgId="print-sigil-svg"
                          />
                        </div>

                        {/* Divider */}
                        <div className="detail-divider"></div>

                        {/* Info section */}
                        <div className="detail-info-section">
                          {/* Mini versions row - spans full width */}
                          <div className="detail-mini-row">
                            <div className="detail-mini-card">
                              <SigilSVG
                                sigil={selectedSigil.sigil}
                                size={getSize(SIZE_RATIOS.miniDisplay)}
                                generatedSize={selectedSigil.sigil.size || getSize(SIZE_RATIOS.genSize)}
                                showGuides={true}
                                showDots={false}
                                showLabels={false}
                                showHeatMap={false}
                                darkMode={effectiveShowcaseDark}
                                thinStroke={effectiveShowcaseDark && !printPreview}
                                printMode={printPreview}
                              />
                              <span className="detail-mini-label">Guides</span>
                            </div>
                            <div className="detail-mini-card">
                              <SigilSVG
                                sigil={selectedSigil.sigil}
                                size={getSize(SIZE_RATIOS.miniDisplay)}
                                generatedSize={selectedSigil.sigil.size || getSize(SIZE_RATIOS.genSize)}
                                showGuides={false}
                                showDots={false}
                                showLabels={true}
                                showHeatMap={false}
                                darkMode={effectiveShowcaseDark}
                                thinStroke={effectiveShowcaseDark && !printPreview}
                                printMode={printPreview}
                              />
                              <span className="detail-mini-label">Labels</span>
                            </div>
                            <div className="detail-mini-card">
                              <SigilSVG
                                sigil={selectedSigil.sigil}
                                size={getSize(SIZE_RATIOS.miniDisplay)}
                                generatedSize={selectedSigil.sigil.size || getSize(SIZE_RATIOS.genSize)}
                                showGuides={false}
                                showDots={false}
                                showLabels={false}
                                showHeatMap={true}
                                heatAnalysis={selectedSigil.heatAnalysis}
                                darkMode={effectiveShowcaseDark}
                                thinStroke={effectiveShowcaseDark && !printPreview}
                                printMode={printPreview}
                              />
                              <span className="detail-mini-label">Heat</span>
                            </div>
                          </div>

                          {/* Divider before letters */}
                          <div className="detail-divider"></div>

                          {/* Letters and numbers - span full width */}
                          <div className="detail-letters">
                            {processed && processed.unique.map((letter, i) => (
                              <span key={i}>{letter}</span>
                            ))}
                          </div>
                          <div className="detail-numbers">
                            {processed && processed.numbers.map((num, i) => (
                              <span key={i}>{num}</span>
                            ))}
                          </div>
                        </div>
                      </div>
                      </div>
                    </div>
                  );})() : (
                    <div className="detail-panel-empty">
                      Click a sigil to view details
                    </div>
                  )}
                </>
              )}
            </div>
              );
            })()}
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<ErrorBoundary><App /></ErrorBoundary>);
  </script>
</body>
</html>
